{"ast":null,"code":"var _s = $RefreshSig$();\n/**\n * useBookmarks Hook\n * Custom hook to manage bookmarked medical conditions with localStorage persistence\n * \n * @returns {Object} - Bookmark state and methods\n */\n\nimport { useCallback } from 'react';\nimport useLocalStorage from './useLocalStorage';\nconst useBookmarks = () => {\n  _s();\n  const [bookmarkedConditions, setBookmarkedConditions] = useLocalStorage('bookmarkedConditions', []);\n\n  // Add a condition to bookmarks\n  const addBookmark = useCallback(condition => {\n    setBookmarkedConditions(prev => {\n      // Check if already bookmarked\n      const isAlreadyBookmarked = prev.some(item => item.name === condition.name);\n      if (isAlreadyBookmarked) {\n        return prev;\n      }\n\n      // Add bookmark with timestamp\n      const bookmarkData = {\n        ...condition,\n        bookmarkedAt: new Date().toISOString(),\n        bookmarkId: `${condition.name}_${Date.now()}`\n      };\n      return [...prev, bookmarkData];\n    });\n  }, [setBookmarkedConditions]);\n\n  // Remove a condition from bookmarks\n  const removeBookmark = useCallback(conditionName => {\n    setBookmarkedConditions(prev => prev.filter(item => item.name !== conditionName));\n  }, [setBookmarkedConditions]);\n\n  // Toggle bookmark status\n  const toggleBookmark = useCallback(condition => {\n    const isBookmarked = bookmarkedConditions.some(item => item.name === condition.name);\n    if (isBookmarked) {\n      removeBookmark(condition.name);\n    } else {\n      addBookmark(condition);\n    }\n    return !isBookmarked; // Return new bookmark status\n  }, [bookmarkedConditions, addBookmark, removeBookmark]);\n\n  // Check if a condition is bookmarked\n  const isBookmarked = useCallback(conditionName => {\n    return bookmarkedConditions.some(item => item.name === conditionName);\n  }, [bookmarkedConditions]);\n\n  // Clear all bookmarks\n  const clearAllBookmarks = useCallback(() => {\n    setBookmarkedConditions([]);\n  }, [setBookmarkedConditions]);\n\n  // Get bookmarks by category\n  const getBookmarksByCategory = useCallback(category => {\n    return bookmarkedConditions.filter(item => item.category.toLowerCase() === category.toLowerCase());\n  }, [bookmarkedConditions]);\n\n  // Get bookmark statistics\n  const bookmarkStats = {\n    totalBookmarks: bookmarkedConditions.length,\n    categories: [...new Set(bookmarkedConditions.map(item => item.category))],\n    recentBookmarks: bookmarkedConditions.sort((a, b) => new Date(b.bookmarkedAt) - new Date(a.bookmarkedAt)).slice(0, 5),\n    oldestBookmark: bookmarkedConditions.length > 0 ? bookmarkedConditions.reduce((oldest, current) => new Date(current.bookmarkedAt) < new Date(oldest.bookmarkedAt) ? current : oldest) : null\n  };\n\n  // Export bookmarks as JSON\n  const exportBookmarks = useCallback(() => {\n    const exportData = {\n      bookmarks: bookmarkedConditions,\n      exportDate: new Date().toISOString(),\n      totalCount: bookmarkedConditions.length\n    };\n    return JSON.stringify(exportData, null, 2);\n  }, [bookmarkedConditions]);\n\n  // Import bookmarks from JSON\n  const importBookmarks = useCallback((jsonData, options = {\n    merge: true\n  }) => {\n    try {\n      const importedData = JSON.parse(jsonData);\n      if (!importedData.bookmarks || !Array.isArray(importedData.bookmarks)) {\n        throw new Error('Invalid bookmark data format');\n      }\n      if (options.merge) {\n        // Merge with existing bookmarks, avoiding duplicates\n        setBookmarkedConditions(prev => {\n          const existing = new Set(prev.map(item => item.name));\n          const newBookmarks = importedData.bookmarks.filter(item => !existing.has(item.name));\n          return [...prev, ...newBookmarks];\n        });\n      } else {\n        // Replace all bookmarks\n        setBookmarkedConditions(importedData.bookmarks);\n      }\n      return {\n        success: true,\n        imported: importedData.bookmarks.length,\n        message: `Successfully imported ${importedData.bookmarks.length} bookmarks`\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message,\n        message: 'Failed to import bookmarks'\n      };\n    }\n  }, [setBookmarkedConditions]);\n  return {\n    // State\n    bookmarkedConditions,\n    bookmarkStats,\n    // Actions\n    addBookmark,\n    removeBookmark,\n    toggleBookmark,\n    isBookmarked,\n    clearAllBookmarks,\n    getBookmarksByCategory,\n    // Import/Export\n    exportBookmarks,\n    importBookmarks\n  };\n};\n_s(useBookmarks, \"+8VNo+dWC27Hxh11/MTX4IeEQU4=\", false, function () {\n  return [useLocalStorage];\n});\nexport default useBookmarks;","map":{"version":3,"names":["useCallback","useLocalStorage","useBookmarks","_s","bookmarkedConditions","setBookmarkedConditions","addBookmark","condition","prev","isAlreadyBookmarked","some","item","name","bookmarkData","bookmarkedAt","Date","toISOString","bookmarkId","now","removeBookmark","conditionName","filter","toggleBookmark","isBookmarked","clearAllBookmarks","getBookmarksByCategory","category","toLowerCase","bookmarkStats","totalBookmarks","length","categories","Set","map","recentBookmarks","sort","a","b","slice","oldestBookmark","reduce","oldest","current","exportBookmarks","exportData","bookmarks","exportDate","totalCount","JSON","stringify","importBookmarks","jsonData","options","merge","importedData","parse","Array","isArray","Error","existing","newBookmarks","has","success","imported","message","error"],"sources":["/Users/joshpankin/My Drive/Obsidian/1. Projects/Antibiotic Learning app/src/hooks/useBookmarks.js"],"sourcesContent":["/**\n * useBookmarks Hook\n * Custom hook to manage bookmarked medical conditions with localStorage persistence\n * \n * @returns {Object} - Bookmark state and methods\n */\n\nimport { useCallback } from 'react';\nimport useLocalStorage from './useLocalStorage';\n\nconst useBookmarks = () => {\n  const [bookmarkedConditions, setBookmarkedConditions] = useLocalStorage('bookmarkedConditions', []);\n\n  // Add a condition to bookmarks\n  const addBookmark = useCallback((condition) => {\n    setBookmarkedConditions(prev => {\n      // Check if already bookmarked\n      const isAlreadyBookmarked = prev.some(item => item.name === condition.name);\n      if (isAlreadyBookmarked) {\n        return prev;\n      }\n      \n      // Add bookmark with timestamp\n      const bookmarkData = {\n        ...condition,\n        bookmarkedAt: new Date().toISOString(),\n        bookmarkId: `${condition.name}_${Date.now()}`\n      };\n      \n      return [...prev, bookmarkData];\n    });\n  }, [setBookmarkedConditions]);\n\n  // Remove a condition from bookmarks\n  const removeBookmark = useCallback((conditionName) => {\n    setBookmarkedConditions(prev => \n      prev.filter(item => item.name !== conditionName)\n    );\n  }, [setBookmarkedConditions]);\n\n  // Toggle bookmark status\n  const toggleBookmark = useCallback((condition) => {\n    const isBookmarked = bookmarkedConditions.some(item => item.name === condition.name);\n    \n    if (isBookmarked) {\n      removeBookmark(condition.name);\n    } else {\n      addBookmark(condition);\n    }\n    \n    return !isBookmarked; // Return new bookmark status\n  }, [bookmarkedConditions, addBookmark, removeBookmark]);\n\n  // Check if a condition is bookmarked\n  const isBookmarked = useCallback((conditionName) => {\n    return bookmarkedConditions.some(item => item.name === conditionName);\n  }, [bookmarkedConditions]);\n\n  // Clear all bookmarks\n  const clearAllBookmarks = useCallback(() => {\n    setBookmarkedConditions([]);\n  }, [setBookmarkedConditions]);\n\n  // Get bookmarks by category\n  const getBookmarksByCategory = useCallback((category) => {\n    return bookmarkedConditions.filter(item => \n      item.category.toLowerCase() === category.toLowerCase()\n    );\n  }, [bookmarkedConditions]);\n\n  // Get bookmark statistics\n  const bookmarkStats = {\n    totalBookmarks: bookmarkedConditions.length,\n    categories: [...new Set(bookmarkedConditions.map(item => item.category))],\n    recentBookmarks: bookmarkedConditions\n      .sort((a, b) => new Date(b.bookmarkedAt) - new Date(a.bookmarkedAt))\n      .slice(0, 5),\n    oldestBookmark: bookmarkedConditions.length > 0 \n      ? bookmarkedConditions.reduce((oldest, current) => \n          new Date(current.bookmarkedAt) < new Date(oldest.bookmarkedAt) ? current : oldest\n        )\n      : null\n  };\n\n  // Export bookmarks as JSON\n  const exportBookmarks = useCallback(() => {\n    const exportData = {\n      bookmarks: bookmarkedConditions,\n      exportDate: new Date().toISOString(),\n      totalCount: bookmarkedConditions.length\n    };\n    \n    return JSON.stringify(exportData, null, 2);\n  }, [bookmarkedConditions]);\n\n  // Import bookmarks from JSON\n  const importBookmarks = useCallback((jsonData, options = { merge: true }) => {\n    try {\n      const importedData = JSON.parse(jsonData);\n      \n      if (!importedData.bookmarks || !Array.isArray(importedData.bookmarks)) {\n        throw new Error('Invalid bookmark data format');\n      }\n      \n      if (options.merge) {\n        // Merge with existing bookmarks, avoiding duplicates\n        setBookmarkedConditions(prev => {\n          const existing = new Set(prev.map(item => item.name));\n          const newBookmarks = importedData.bookmarks.filter(item => !existing.has(item.name));\n          return [...prev, ...newBookmarks];\n        });\n      } else {\n        // Replace all bookmarks\n        setBookmarkedConditions(importedData.bookmarks);\n      }\n      \n      return {\n        success: true,\n        imported: importedData.bookmarks.length,\n        message: `Successfully imported ${importedData.bookmarks.length} bookmarks`\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message,\n        message: 'Failed to import bookmarks'\n      };\n    }\n  }, [setBookmarkedConditions]);\n\n  return {\n    // State\n    bookmarkedConditions,\n    bookmarkStats,\n    \n    // Actions\n    addBookmark,\n    removeBookmark,\n    toggleBookmark,\n    isBookmarked,\n    clearAllBookmarks,\n    getBookmarksByCategory,\n    \n    // Import/Export\n    exportBookmarks,\n    importBookmarks\n  };\n};\n\nexport default useBookmarks;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}