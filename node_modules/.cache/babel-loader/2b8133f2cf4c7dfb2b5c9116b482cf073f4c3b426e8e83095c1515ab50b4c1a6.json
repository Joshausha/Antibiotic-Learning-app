{"ast":null,"code":"var _s = $RefreshSig$();\n/**\n * usePathogenRecommendations Hook\n * Smart recommendation engine for pathogen learning suggestions\n * Provides personalized recommendations based on user behavior and learning patterns\n */\n\nimport { useState, useEffect, useMemo, useCallback } from 'react';\nimport { getPathogenRecommendations, buildPathogenNetwork, calculatePathogenSimilarity } from '../utils/dataIndexer';\nconst usePathogenRecommendations = (indexes, selectedPathogen, userBehavior = {}) => {\n  _s();\n  const [recommendations, setRecommendations] = useState([]);\n  const [learningPath, setLearningPath] = useState([]);\n  const [userPreferences, setUserPreferences] = useState({\n    systematicLearning: false,\n    preferSimilarPathogens: true,\n    includeRecentlyViewed: false,\n    difficultyLevel: 'adaptive',\n    // 'beginner', 'intermediate', 'advanced', 'adaptive'\n    focusAreas: [] // Array of categories the user is interested in\n  });\n  const [sessionStats, setSessionStats] = useState({\n    totalViewed: 0,\n    averageTimePerPathogen: 0,\n    preferredCategories: new Map(),\n    gramStatusFocus: new Map(),\n    explorationDepth: 0\n  });\n\n  // Extract user behavior patterns\n  const behaviorAnalysis = useMemo(() => {\n    var _Array$from$sort$;\n    if (!userBehavior.history || userBehavior.history.length === 0) {\n      return {\n        mostViewedCategories: [],\n        gramStatusPreference: null,\n        averageSessionLength: 0,\n        explorationStyle: 'systematic',\n        // 'systematic', 'random', 'focused'\n        difficultyProgression: 'steady'\n      };\n    }\n    const history = userBehavior.history;\n\n    // Analyze category preferences\n    const categoryCount = new Map();\n    const gramStatusCount = new Map();\n    let totalSessionTime = 0;\n    history.forEach(item => {\n      var _item$pathogen, _item$pathogen2;\n      // Count categories\n      if ((_item$pathogen = item.pathogen) !== null && _item$pathogen !== void 0 && _item$pathogen.conditions) {\n        item.pathogen.conditions.forEach(conditionId => {\n          const condition = indexes === null || indexes === void 0 ? void 0 : indexes.conditions.find(c => c.id === conditionId);\n          if (condition) {\n            categoryCount.set(condition.category, (categoryCount.get(condition.category) || 0) + 1);\n          }\n        });\n      }\n\n      // Count gram status preferences\n      if ((_item$pathogen2 = item.pathogen) !== null && _item$pathogen2 !== void 0 && _item$pathogen2.gramStatus) {\n        gramStatusCount.set(item.pathogen.gramStatus, (gramStatusCount.get(item.pathogen.gramStatus) || 0) + 1);\n      }\n\n      // Sum session times\n      if (item.timeSpent) {\n        totalSessionTime += item.timeSpent;\n      }\n    });\n\n    // Determine exploration style\n    const uniquePathogens = new Set(history.map(h => {\n      var _h$pathogen;\n      return (_h$pathogen = h.pathogen) === null || _h$pathogen === void 0 ? void 0 : _h$pathogen.name;\n    })).size;\n    const totalViews = history.length;\n    const revisitRate = totalViews > 0 ? (totalViews - uniquePathogens) / totalViews : 0;\n    let explorationStyle = 'systematic';\n    if (revisitRate > 0.3) {\n      explorationStyle = 'focused';\n    } else if (uniquePathogens > totalViews * 0.8) {\n      explorationStyle = 'random';\n    }\n    return {\n      mostViewedCategories: Array.from(categoryCount.entries()).sort(([, a], [, b]) => b - a).slice(0, 3).map(([category]) => category),\n      gramStatusPreference: ((_Array$from$sort$ = Array.from(gramStatusCount.entries()).sort(([, a], [, b]) => b - a)[0]) === null || _Array$from$sort$ === void 0 ? void 0 : _Array$from$sort$[0]) || null,\n      averageSessionLength: totalSessionTime / Math.max(1, totalViews),\n      explorationStyle,\n      difficultyProgression: 'steady' // This could be enhanced with more sophisticated analysis\n    };\n  }, [userBehavior, indexes]);\n\n  // Update user preferences based on behavior\n  useEffect(() => {\n    setUserPreferences(prev => ({\n      ...prev,\n      systematicLearning: behaviorAnalysis.explorationStyle === 'systematic',\n      focusAreas: behaviorAnalysis.mostViewedCategories\n    }));\n  }, [behaviorAnalysis]);\n\n  // Calculate personalized recommendations\n  const calculateRecommendations = useCallback(() => {\n    if (!selectedPathogen || !indexes) {\n      setRecommendations([]);\n      return;\n    }\n\n    // Get base recommendations\n    const baseRecs = getPathogenRecommendations(indexes, selectedPathogen.name, userBehavior.recentlyViewed || [], userPreferences);\n\n    // Enhance recommendations with personalization\n    const enhancedRecs = baseRecs.map(rec => {\n      var _pathogen$conditions;\n      const pathogen = indexes.pathogens.find(p => p.name === rec.pathogen);\n      if (!pathogen) return rec;\n      let personalizedScore = rec.weight;\n      let personalizedReasoning = rec.reasoning;\n\n      // Boost score based on user category preferences\n      if (pathogen.conditions && userPreferences.focusAreas.length > 0) {\n        const pathogenCategories = pathogen.conditions.map(condId => {\n          var _indexes$conditions$f;\n          return (_indexes$conditions$f = indexes.conditions.find(c => c.id === condId)) === null || _indexes$conditions$f === void 0 ? void 0 : _indexes$conditions$f.category;\n        }).filter(Boolean);\n        const categoryMatch = pathogenCategories.some(cat => userPreferences.focusAreas.includes(cat));\n        if (categoryMatch) {\n          personalizedScore *= 1.3;\n          personalizedReasoning += ' (matches your interests)';\n        }\n      }\n\n      // Boost score based on gram status preference\n      if (behaviorAnalysis.gramStatusPreference && pathogen.gramStatus === behaviorAnalysis.gramStatusPreference) {\n        personalizedScore *= 1.2;\n        personalizedReasoning += ' (preferred gram status)';\n      }\n\n      // Adjust based on difficulty level\n      const pathogenComplexity = pathogen.conditions.length + (indexes.pathogenAntibioticMatrix.get(pathogen.name) || []).length;\n      if (userPreferences.difficultyLevel !== 'adaptive') {\n        const targetComplexity = {\n          beginner: [1, 4],\n          intermediate: [4, 8],\n          advanced: [8, Infinity]\n        }[userPreferences.difficultyLevel] || [1, Infinity];\n        if (pathogenComplexity >= targetComplexity[0] && pathogenComplexity < targetComplexity[1]) {\n          personalizedScore *= 1.25;\n          personalizedReasoning += ` (${userPreferences.difficultyLevel} level)`;\n        }\n      }\n      return {\n        ...rec,\n        personalizedScore,\n        originalScore: rec.weight,\n        personalizedReasoning,\n        pathogenComplexity,\n        userRelevance: {\n          categoryMatch: (_pathogen$conditions = pathogen.conditions) === null || _pathogen$conditions === void 0 ? void 0 : _pathogen$conditions.some(condId => {\n            const condition = indexes.conditions.find(c => c.id === condId);\n            return condition && userPreferences.focusAreas.includes(condition.category);\n          }),\n          gramStatusMatch: pathogen.gramStatus === behaviorAnalysis.gramStatusPreference,\n          difficultyMatch: userPreferences.difficultyLevel === 'adaptive' || (() => {\n            const targetComplexity = {\n              beginner: [1, 4],\n              intermediate: [4, 8],\n              advanced: [8, Infinity]\n            }[userPreferences.difficultyLevel] || [1, Infinity];\n            return pathogenComplexity >= targetComplexity[0] && pathogenComplexity < targetComplexity[1];\n          })()\n        }\n      };\n    });\n\n    // Sort by personalized score\n    enhancedRecs.sort((a, b) => b.personalizedScore - a.personalizedScore);\n    setRecommendations(enhancedRecs);\n  }, [selectedPathogen, indexes, userBehavior, userPreferences, behaviorAnalysis]);\n\n  // Generate learning path recommendations\n  const generateLearningPath = useCallback(() => {\n    if (!selectedPathogen || !indexes) {\n      setLearningPath([]);\n      return;\n    }\n    const network = buildPathogenNetwork(indexes);\n    const startingNode = network.nodes.find(n => n.id === selectedPathogen.name);\n    if (!startingNode) {\n      setLearningPath([]);\n      return;\n    }\n    let path = [selectedPathogen];\n    let currentPathogen = selectedPathogen;\n    const visited = new Set([selectedPathogen.name]);\n\n    // Build a learning path based on user preferences\n    for (let step = 0; step < 5; step++) {\n      const candidates = network.edges.filter(e => (e.source === currentPathogen.name || e.target === currentPathogen.name) && !visited.has(e.source === currentPathogen.name ? e.target : e.source)).map(e => {\n        const targetName = e.source === currentPathogen.name ? e.target : e.source;\n        const targetPathogen = indexes.pathogens.find(p => p.name === targetName);\n        return {\n          pathogen: targetPathogen,\n          similarity: e.similarity,\n          weight: e.weight\n        };\n      }).filter(c => c.pathogen);\n      if (candidates.length === 0) break;\n\n      // Score candidates based on learning objectives\n      const scoredCandidates = candidates.map(candidate => {\n        let score = candidate.weight;\n\n        // Progressive difficulty\n        if (userPreferences.difficultyLevel === 'adaptive') {\n          const currentComplexity = currentPathogen.conditions.length;\n          const candidateComplexity = candidate.pathogen.conditions.length;\n          const complexityDiff = candidateComplexity - currentComplexity;\n\n          // Prefer gradual increase in complexity\n          if (complexityDiff >= 0 && complexityDiff <= 2) {\n            score *= 1.3;\n          }\n        }\n\n        // Category diversity vs focus\n        if (userPreferences.systematicLearning) {\n          // Prefer same categories for systematic learning\n          const currentCategories = new Set(currentPathogen.conditions.map(condId => {\n            var _indexes$conditions$f2;\n            return (_indexes$conditions$f2 = indexes.conditions.find(c => c.id === condId)) === null || _indexes$conditions$f2 === void 0 ? void 0 : _indexes$conditions$f2.category;\n          }).filter(Boolean));\n          const candidateCategories = new Set(candidate.pathogen.conditions.map(condId => {\n            var _indexes$conditions$f3;\n            return (_indexes$conditions$f3 = indexes.conditions.find(c => c.id === condId)) === null || _indexes$conditions$f3 === void 0 ? void 0 : _indexes$conditions$f3.category;\n          }).filter(Boolean));\n          const overlap = Array.from(currentCategories).filter(cat => candidateCategories.has(cat)).length;\n          score *= 1 + overlap * 0.2;\n        }\n        return {\n          ...candidate,\n          learningScore: score\n        };\n      });\n\n      // Select best candidate\n      scoredCandidates.sort((a, b) => b.learningScore - a.learningScore);\n      const nextPathogen = scoredCandidates[0].pathogen;\n      path.push(nextPathogen);\n      visited.add(nextPathogen.name);\n      currentPathogen = nextPathogen;\n    }\n    setLearningPath(path);\n  }, [selectedPathogen, indexes, userPreferences]);\n\n  // Update recommendations when dependencies change\n  useEffect(() => {\n    calculateRecommendations();\n    generateLearningPath();\n  }, [calculateRecommendations, generateLearningPath]);\n\n  // Track user interactions for learning\n  const recordInteraction = useCallback((pathogen, interactionType, timeSpent = 0) => {\n    setSessionStats(prev => {\n      const newStats = {\n        ...prev\n      };\n      newStats.totalViewed += 1;\n      if (timeSpent > 0) {\n        newStats.averageTimePerPathogen = (newStats.averageTimePerPathogen * (newStats.totalViewed - 1) + timeSpent) / newStats.totalViewed;\n      }\n\n      // Update category preferences\n      if (pathogen.conditions) {\n        pathogen.conditions.forEach(conditionId => {\n          const condition = indexes === null || indexes === void 0 ? void 0 : indexes.conditions.find(c => c.id === conditionId);\n          if (condition) {\n            const currentCount = newStats.preferredCategories.get(condition.category) || 0;\n            newStats.preferredCategories.set(condition.category, currentCount + 1);\n          }\n        });\n      }\n\n      // Update gram status preferences\n      if (pathogen.gramStatus) {\n        const currentCount = newStats.gramStatusFocus.get(pathogen.gramStatus) || 0;\n        newStats.gramStatusFocus.set(pathogen.gramStatus, currentCount + 1);\n      }\n      return newStats;\n    });\n  }, [indexes]);\n\n  // Get recommendation categories\n  const getRecommendationsByCategory = useMemo(() => {\n    const categorized = {\n      'Similar': recommendations.filter(r => r.reasoning.includes('similarity')),\n      'Your Interests': recommendations.filter(r => {\n        var _r$userRelevance;\n        return (_r$userRelevance = r.userRelevance) === null || _r$userRelevance === void 0 ? void 0 : _r$userRelevance.categoryMatch;\n      }),\n      'Next Level': recommendations.filter(r => {\n        var _selectedPathogen$con;\n        return r.pathogenComplexity > ((selectedPathogen === null || selectedPathogen === void 0 ? void 0 : (_selectedPathogen$con = selectedPathogen.conditions) === null || _selectedPathogen$con === void 0 ? void 0 : _selectedPathogen$con.length) || 0);\n      }),\n      'Recently Popular': recommendations.filter(r => r.reasoning.includes('popular')),\n      'Discover': recommendations.filter(r => {\n        var _r$userRelevance2;\n        return !((_r$userRelevance2 = r.userRelevance) !== null && _r$userRelevance2 !== void 0 && _r$userRelevance2.categoryMatch) && !r.reasoning.includes('similarity');\n      })\n    };\n\n    // Filter out empty categories\n    return Object.fromEntries(Object.entries(categorized).filter(([, recs]) => recs.length > 0));\n  }, [recommendations, selectedPathogen]);\n  return {\n    recommendations,\n    learningPath,\n    userPreferences,\n    setUserPreferences,\n    sessionStats,\n    behaviorAnalysis,\n    recordInteraction,\n    getRecommendationsByCategory,\n    // Actions\n    refreshRecommendations: calculateRecommendations,\n    regenerateLearningPath: generateLearningPath\n  };\n};\n_s(usePathogenRecommendations, \"1wcM/5RhtIHkKqtKdJnmPaBJ7Xk=\");\nexport default usePathogenRecommendations;","map":{"version":3,"names":["useState","useEffect","useMemo","useCallback","getPathogenRecommendations","buildPathogenNetwork","calculatePathogenSimilarity","usePathogenRecommendations","indexes","selectedPathogen","userBehavior","_s","recommendations","setRecommendations","learningPath","setLearningPath","userPreferences","setUserPreferences","systematicLearning","preferSimilarPathogens","includeRecentlyViewed","difficultyLevel","focusAreas","sessionStats","setSessionStats","totalViewed","averageTimePerPathogen","preferredCategories","Map","gramStatusFocus","explorationDepth","behaviorAnalysis","_Array$from$sort$","history","length","mostViewedCategories","gramStatusPreference","averageSessionLength","explorationStyle","difficultyProgression","categoryCount","gramStatusCount","totalSessionTime","forEach","item","_item$pathogen","_item$pathogen2","pathogen","conditions","conditionId","condition","find","c","id","set","category","get","gramStatus","timeSpent","uniquePathogens","Set","map","h","_h$pathogen","name","size","totalViews","revisitRate","Array","from","entries","sort","a","b","slice","Math","max","prev","calculateRecommendations","baseRecs","recentlyViewed","enhancedRecs","rec","_pathogen$conditions","pathogens","p","personalizedScore","weight","personalizedReasoning","reasoning","pathogenCategories","condId","_indexes$conditions$f","filter","Boolean","categoryMatch","some","cat","includes","pathogenComplexity","pathogenAntibioticMatrix","targetComplexity","beginner","intermediate","advanced","Infinity","originalScore","userRelevance","gramStatusMatch","difficultyMatch","generateLearningPath","network","startingNode","nodes","n","path","currentPathogen","visited","step","candidates","edges","e","source","target","has","targetName","targetPathogen","similarity","scoredCandidates","candidate","score","currentComplexity","candidateComplexity","complexityDiff","currentCategories","_indexes$conditions$f2","candidateCategories","_indexes$conditions$f3","overlap","learningScore","nextPathogen","push","add","recordInteraction","interactionType","newStats","currentCount","getRecommendationsByCategory","categorized","r","_r$userRelevance","_selectedPathogen$con","_r$userRelevance2","Object","fromEntries","recs","refreshRecommendations","regenerateLearningPath"],"sources":["/Users/joshpankin/My Drive/Obsidian/1. Projects/Antibiotic Learning app/src/hooks/usePathogenRecommendations.js"],"sourcesContent":["/**\n * usePathogenRecommendations Hook\n * Smart recommendation engine for pathogen learning suggestions\n * Provides personalized recommendations based on user behavior and learning patterns\n */\n\nimport { useState, useEffect, useMemo, useCallback } from 'react';\nimport { getPathogenRecommendations, buildPathogenNetwork, calculatePathogenSimilarity } from '../utils/dataIndexer';\n\nconst usePathogenRecommendations = (indexes, selectedPathogen, userBehavior = {}) => {\n  const [recommendations, setRecommendations] = useState([]);\n  const [learningPath, setLearningPath] = useState([]);\n  const [userPreferences, setUserPreferences] = useState({\n    systematicLearning: false,\n    preferSimilarPathogens: true,\n    includeRecentlyViewed: false,\n    difficultyLevel: 'adaptive', // 'beginner', 'intermediate', 'advanced', 'adaptive'\n    focusAreas: [] // Array of categories the user is interested in\n  });\n  const [sessionStats, setSessionStats] = useState({\n    totalViewed: 0,\n    averageTimePerPathogen: 0,\n    preferredCategories: new Map(),\n    gramStatusFocus: new Map(),\n    explorationDepth: 0\n  });\n\n  // Extract user behavior patterns\n  const behaviorAnalysis = useMemo(() => {\n    if (!userBehavior.history || userBehavior.history.length === 0) {\n      return {\n        mostViewedCategories: [],\n        gramStatusPreference: null,\n        averageSessionLength: 0,\n        explorationStyle: 'systematic', // 'systematic', 'random', 'focused'\n        difficultyProgression: 'steady'\n      };\n    }\n\n    const history = userBehavior.history;\n    \n    // Analyze category preferences\n    const categoryCount = new Map();\n    const gramStatusCount = new Map();\n    let totalSessionTime = 0;\n    \n    history.forEach(item => {\n      // Count categories\n      if (item.pathogen?.conditions) {\n        item.pathogen.conditions.forEach(conditionId => {\n          const condition = indexes?.conditions.find(c => c.id === conditionId);\n          if (condition) {\n            categoryCount.set(condition.category, (categoryCount.get(condition.category) || 0) + 1);\n          }\n        });\n      }\n      \n      // Count gram status preferences\n      if (item.pathogen?.gramStatus) {\n        gramStatusCount.set(\n          item.pathogen.gramStatus, \n          (gramStatusCount.get(item.pathogen.gramStatus) || 0) + 1\n        );\n      }\n      \n      // Sum session times\n      if (item.timeSpent) {\n        totalSessionTime += item.timeSpent;\n      }\n    });\n\n    // Determine exploration style\n    const uniquePathogens = new Set(history.map(h => h.pathogen?.name)).size;\n    const totalViews = history.length;\n    const revisitRate = totalViews > 0 ? (totalViews - uniquePathogens) / totalViews : 0;\n    \n    let explorationStyle = 'systematic';\n    if (revisitRate > 0.3) {\n      explorationStyle = 'focused';\n    } else if (uniquePathogens > totalViews * 0.8) {\n      explorationStyle = 'random';\n    }\n\n    return {\n      mostViewedCategories: Array.from(categoryCount.entries())\n        .sort(([,a], [,b]) => b - a)\n        .slice(0, 3)\n        .map(([category]) => category),\n      gramStatusPreference: Array.from(gramStatusCount.entries())\n        .sort(([,a], [,b]) => b - a)[0]?.[0] || null,\n      averageSessionLength: totalSessionTime / Math.max(1, totalViews),\n      explorationStyle,\n      difficultyProgression: 'steady' // This could be enhanced with more sophisticated analysis\n    };\n  }, [userBehavior, indexes]);\n\n  // Update user preferences based on behavior\n  useEffect(() => {\n    setUserPreferences(prev => ({\n      ...prev,\n      systematicLearning: behaviorAnalysis.explorationStyle === 'systematic',\n      focusAreas: behaviorAnalysis.mostViewedCategories\n    }));\n  }, [behaviorAnalysis]);\n\n  // Calculate personalized recommendations\n  const calculateRecommendations = useCallback(() => {\n    if (!selectedPathogen || !indexes) {\n      setRecommendations([]);\n      return;\n    }\n\n    // Get base recommendations\n    const baseRecs = getPathogenRecommendations(\n      indexes,\n      selectedPathogen.name,\n      userBehavior.recentlyViewed || [],\n      userPreferences\n    );\n\n    // Enhance recommendations with personalization\n    const enhancedRecs = baseRecs.map(rec => {\n      const pathogen = indexes.pathogens.find(p => p.name === rec.pathogen);\n      if (!pathogen) return rec;\n\n      let personalizedScore = rec.weight;\n      let personalizedReasoning = rec.reasoning;\n\n      // Boost score based on user category preferences\n      if (pathogen.conditions && userPreferences.focusAreas.length > 0) {\n        const pathogenCategories = pathogen.conditions\n          .map(condId => indexes.conditions.find(c => c.id === condId)?.category)\n          .filter(Boolean);\n        \n        const categoryMatch = pathogenCategories.some(cat => \n          userPreferences.focusAreas.includes(cat)\n        );\n        \n        if (categoryMatch) {\n          personalizedScore *= 1.3;\n          personalizedReasoning += ' (matches your interests)';\n        }\n      }\n\n      // Boost score based on gram status preference\n      if (behaviorAnalysis.gramStatusPreference && \n          pathogen.gramStatus === behaviorAnalysis.gramStatusPreference) {\n        personalizedScore *= 1.2;\n        personalizedReasoning += ' (preferred gram status)';\n      }\n\n      // Adjust based on difficulty level\n      const pathogenComplexity = pathogen.conditions.length + \n        (indexes.pathogenAntibioticMatrix.get(pathogen.name) || []).length;\n      \n      if (userPreferences.difficultyLevel !== 'adaptive') {\n        const targetComplexity = {\n          beginner: [1, 4],\n          intermediate: [4, 8],\n          advanced: [8, Infinity]\n        }[userPreferences.difficultyLevel] || [1, Infinity];\n\n        if (pathogenComplexity >= targetComplexity[0] && pathogenComplexity < targetComplexity[1]) {\n          personalizedScore *= 1.25;\n          personalizedReasoning += ` (${userPreferences.difficultyLevel} level)`;\n        }\n      }\n\n      return {\n        ...rec,\n        personalizedScore,\n        originalScore: rec.weight,\n        personalizedReasoning,\n        pathogenComplexity,\n        userRelevance: {\n          categoryMatch: pathogen.conditions?.some(condId => {\n            const condition = indexes.conditions.find(c => c.id === condId);\n            return condition && userPreferences.focusAreas.includes(condition.category);\n          }),\n          gramStatusMatch: pathogen.gramStatus === behaviorAnalysis.gramStatusPreference,\n          difficultyMatch: userPreferences.difficultyLevel === 'adaptive' || (() => {\n            const targetComplexity = {\n              beginner: [1, 4],\n              intermediate: [4, 8],\n              advanced: [8, Infinity]\n            }[userPreferences.difficultyLevel] || [1, Infinity];\n            return pathogenComplexity >= targetComplexity[0] && pathogenComplexity < targetComplexity[1];\n          })()\n        }\n      };\n    });\n\n    // Sort by personalized score\n    enhancedRecs.sort((a, b) => b.personalizedScore - a.personalizedScore);\n\n    setRecommendations(enhancedRecs);\n  }, [selectedPathogen, indexes, userBehavior, userPreferences, behaviorAnalysis]);\n\n  // Generate learning path recommendations\n  const generateLearningPath = useCallback(() => {\n    if (!selectedPathogen || !indexes) {\n      setLearningPath([]);\n      return;\n    }\n\n    const network = buildPathogenNetwork(indexes);\n    const startingNode = network.nodes.find(n => n.id === selectedPathogen.name);\n    \n    if (!startingNode) {\n      setLearningPath([]);\n      return;\n    }\n\n    let path = [selectedPathogen];\n    let currentPathogen = selectedPathogen;\n    const visited = new Set([selectedPathogen.name]);\n\n    // Build a learning path based on user preferences\n    for (let step = 0; step < 5; step++) {\n      const candidates = network.edges\n        .filter(e => \n          (e.source === currentPathogen.name || e.target === currentPathogen.name) &&\n          !visited.has(e.source === currentPathogen.name ? e.target : e.source)\n        )\n        .map(e => {\n          const targetName = e.source === currentPathogen.name ? e.target : e.source;\n          const targetPathogen = indexes.pathogens.find(p => p.name === targetName);\n          return {\n            pathogen: targetPathogen,\n            similarity: e.similarity,\n            weight: e.weight\n          };\n        })\n        .filter(c => c.pathogen);\n\n      if (candidates.length === 0) break;\n\n      // Score candidates based on learning objectives\n      const scoredCandidates = candidates.map(candidate => {\n        let score = candidate.weight;\n\n        // Progressive difficulty\n        if (userPreferences.difficultyLevel === 'adaptive') {\n          const currentComplexity = currentPathogen.conditions.length;\n          const candidateComplexity = candidate.pathogen.conditions.length;\n          const complexityDiff = candidateComplexity - currentComplexity;\n          \n          // Prefer gradual increase in complexity\n          if (complexityDiff >= 0 && complexityDiff <= 2) {\n            score *= 1.3;\n          }\n        }\n\n        // Category diversity vs focus\n        if (userPreferences.systematicLearning) {\n          // Prefer same categories for systematic learning\n          const currentCategories = new Set(currentPathogen.conditions.map(condId => \n            indexes.conditions.find(c => c.id === condId)?.category\n          ).filter(Boolean));\n          \n          const candidateCategories = new Set(candidate.pathogen.conditions.map(condId =>\n            indexes.conditions.find(c => c.id === condId)?.category\n          ).filter(Boolean));\n          \n          const overlap = Array.from(currentCategories).filter(cat => candidateCategories.has(cat)).length;\n          score *= (1 + overlap * 0.2);\n        }\n\n        return { ...candidate, learningScore: score };\n      });\n\n      // Select best candidate\n      scoredCandidates.sort((a, b) => b.learningScore - a.learningScore);\n      const nextPathogen = scoredCandidates[0].pathogen;\n      \n      path.push(nextPathogen);\n      visited.add(nextPathogen.name);\n      currentPathogen = nextPathogen;\n    }\n\n    setLearningPath(path);\n  }, [selectedPathogen, indexes, userPreferences]);\n\n  // Update recommendations when dependencies change\n  useEffect(() => {\n    calculateRecommendations();\n    generateLearningPath();\n  }, [calculateRecommendations, generateLearningPath]);\n\n  // Track user interactions for learning\n  const recordInteraction = useCallback((pathogen, interactionType, timeSpent = 0) => {\n    setSessionStats(prev => {\n      const newStats = { ...prev };\n      newStats.totalViewed += 1;\n      \n      if (timeSpent > 0) {\n        newStats.averageTimePerPathogen = \n          (newStats.averageTimePerPathogen * (newStats.totalViewed - 1) + timeSpent) / newStats.totalViewed;\n      }\n\n      // Update category preferences\n      if (pathogen.conditions) {\n        pathogen.conditions.forEach(conditionId => {\n          const condition = indexes?.conditions.find(c => c.id === conditionId);\n          if (condition) {\n            const currentCount = newStats.preferredCategories.get(condition.category) || 0;\n            newStats.preferredCategories.set(condition.category, currentCount + 1);\n          }\n        });\n      }\n\n      // Update gram status preferences\n      if (pathogen.gramStatus) {\n        const currentCount = newStats.gramStatusFocus.get(pathogen.gramStatus) || 0;\n        newStats.gramStatusFocus.set(pathogen.gramStatus, currentCount + 1);\n      }\n\n      return newStats;\n    });\n  }, [indexes]);\n\n  // Get recommendation categories\n  const getRecommendationsByCategory = useMemo(() => {\n    const categorized = {\n      'Similar': recommendations.filter(r => r.reasoning.includes('similarity')),\n      'Your Interests': recommendations.filter(r => r.userRelevance?.categoryMatch),\n      'Next Level': recommendations.filter(r => r.pathogenComplexity > (selectedPathogen?.conditions?.length || 0)),\n      'Recently Popular': recommendations.filter(r => r.reasoning.includes('popular')),\n      'Discover': recommendations.filter(r => !r.userRelevance?.categoryMatch && !r.reasoning.includes('similarity'))\n    };\n\n    // Filter out empty categories\n    return Object.fromEntries(\n      Object.entries(categorized).filter(([, recs]) => recs.length > 0)\n    );\n  }, [recommendations, selectedPathogen]);\n\n  return {\n    recommendations,\n    learningPath,\n    userPreferences,\n    setUserPreferences,\n    sessionStats,\n    behaviorAnalysis,\n    recordInteraction,\n    getRecommendationsByCategory,\n    \n    // Actions\n    refreshRecommendations: calculateRecommendations,\n    regenerateLearningPath: generateLearningPath\n  };\n};\n\nexport default usePathogenRecommendations;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}