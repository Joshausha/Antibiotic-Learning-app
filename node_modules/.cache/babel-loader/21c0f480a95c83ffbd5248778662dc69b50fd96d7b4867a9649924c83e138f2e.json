{"ast":null,"code":"import _objectSpread from\"/Users/joshpankin/My Drive/Obsidian/1. Projects/Antibiotic Learning app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";/**\n * useBookmarks Hook\n * Custom hook to manage bookmarked medical conditions with localStorage persistence\n * \n * @returns {Object} - Bookmark state and methods\n */import{useCallback}from'react';import useLocalStorage from'./useLocalStorage';const useBookmarks=()=>{const[bookmarkedConditions,setBookmarkedConditions]=useLocalStorage('bookmarkedConditions',[]);// Add a condition to bookmarks\nconst addBookmark=useCallback(condition=>{setBookmarkedConditions(prev=>{// Check if already bookmarked\nconst isAlreadyBookmarked=prev.some(item=>item.name===condition.name);if(isAlreadyBookmarked){return prev;}// Add bookmark with timestamp\nconst bookmarkData=_objectSpread(_objectSpread({},condition),{},{bookmarkedAt:new Date().toISOString(),bookmarkId:\"\".concat(condition.name,\"_\").concat(Date.now())});return[...prev,bookmarkData];});},[setBookmarkedConditions]);// Remove a condition from bookmarks\nconst removeBookmark=useCallback(conditionName=>{setBookmarkedConditions(prev=>prev.filter(item=>item.name!==conditionName));},[setBookmarkedConditions]);// Toggle bookmark status\nconst toggleBookmark=useCallback(condition=>{const isBookmarked=bookmarkedConditions.some(item=>item.name===condition.name);if(isBookmarked){removeBookmark(condition.name);}else{addBookmark(condition);}return!isBookmarked;// Return new bookmark status\n},[bookmarkedConditions,addBookmark,removeBookmark]);// Check if a condition is bookmarked\nconst isBookmarked=useCallback(conditionName=>{return bookmarkedConditions.some(item=>item.name===conditionName);},[bookmarkedConditions]);// Clear all bookmarks\nconst clearAllBookmarks=useCallback(()=>{setBookmarkedConditions([]);},[setBookmarkedConditions]);// Get bookmarks by category\nconst getBookmarksByCategory=useCallback(category=>{return bookmarkedConditions.filter(item=>item.category.toLowerCase()===category.toLowerCase());},[bookmarkedConditions]);// Get bookmark statistics\nconst bookmarkStats={totalBookmarks:bookmarkedConditions.length,categories:[...new Set(bookmarkedConditions.map(item=>item.category))],recentBookmarks:bookmarkedConditions.sort((a,b)=>new Date(b.bookmarkedAt)-new Date(a.bookmarkedAt)).slice(0,5),oldestBookmark:bookmarkedConditions.length>0?bookmarkedConditions.reduce((oldest,current)=>new Date(current.bookmarkedAt)<new Date(oldest.bookmarkedAt)?current:oldest):null};// Export bookmarks as JSON\nconst exportBookmarks=useCallback(()=>{const exportData={bookmarks:bookmarkedConditions,exportDate:new Date().toISOString(),totalCount:bookmarkedConditions.length};return JSON.stringify(exportData,null,2);},[bookmarkedConditions]);// Import bookmarks from JSON\nconst importBookmarks=useCallback(function(jsonData){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{merge:true};try{const importedData=JSON.parse(jsonData);if(!importedData.bookmarks||!Array.isArray(importedData.bookmarks)){throw new Error('Invalid bookmark data format');}if(options.merge){// Merge with existing bookmarks, avoiding duplicates\nsetBookmarkedConditions(prev=>{const existing=new Set(prev.map(item=>item.name));const newBookmarks=importedData.bookmarks.filter(item=>!existing.has(item.name));return[...prev,...newBookmarks];});}else{// Replace all bookmarks\nsetBookmarkedConditions(importedData.bookmarks);}return{success:true,imported:importedData.bookmarks.length,message:\"Successfully imported \".concat(importedData.bookmarks.length,\" bookmarks\")};}catch(error){return{success:false,error:error.message,message:'Failed to import bookmarks'};}},[setBookmarkedConditions]);return{// State\nbookmarkedConditions,bookmarkStats,// Actions\naddBookmark,removeBookmark,toggleBookmark,isBookmarked,clearAllBookmarks,getBookmarksByCategory,// Import/Export\nexportBookmarks,importBookmarks};};export default useBookmarks;","map":{"version":3,"names":["useCallback","useLocalStorage","useBookmarks","bookmarkedConditions","setBookmarkedConditions","addBookmark","condition","prev","isAlreadyBookmarked","some","item","name","bookmarkData","_objectSpread","bookmarkedAt","Date","toISOString","bookmarkId","concat","now","removeBookmark","conditionName","filter","toggleBookmark","isBookmarked","clearAllBookmarks","getBookmarksByCategory","category","toLowerCase","bookmarkStats","totalBookmarks","length","categories","Set","map","recentBookmarks","sort","a","b","slice","oldestBookmark","reduce","oldest","current","exportBookmarks","exportData","bookmarks","exportDate","totalCount","JSON","stringify","importBookmarks","jsonData","options","arguments","undefined","merge","importedData","parse","Array","isArray","Error","existing","newBookmarks","has","success","imported","message","error"],"sources":["/Users/joshpankin/My Drive/Obsidian/1. Projects/Antibiotic Learning app/src/hooks/useBookmarks.js"],"sourcesContent":["/**\n * useBookmarks Hook\n * Custom hook to manage bookmarked medical conditions with localStorage persistence\n * \n * @returns {Object} - Bookmark state and methods\n */\n\nimport { useCallback } from 'react';\nimport useLocalStorage from './useLocalStorage';\n\nconst useBookmarks = () => {\n  const [bookmarkedConditions, setBookmarkedConditions] = useLocalStorage('bookmarkedConditions', []);\n\n  // Add a condition to bookmarks\n  const addBookmark = useCallback((condition) => {\n    setBookmarkedConditions(prev => {\n      // Check if already bookmarked\n      const isAlreadyBookmarked = prev.some(item => item.name === condition.name);\n      if (isAlreadyBookmarked) {\n        return prev;\n      }\n      \n      // Add bookmark with timestamp\n      const bookmarkData = {\n        ...condition,\n        bookmarkedAt: new Date().toISOString(),\n        bookmarkId: `${condition.name}_${Date.now()}`\n      };\n      \n      return [...prev, bookmarkData];\n    });\n  }, [setBookmarkedConditions]);\n\n  // Remove a condition from bookmarks\n  const removeBookmark = useCallback((conditionName) => {\n    setBookmarkedConditions(prev => \n      prev.filter(item => item.name !== conditionName)\n    );\n  }, [setBookmarkedConditions]);\n\n  // Toggle bookmark status\n  const toggleBookmark = useCallback((condition) => {\n    const isBookmarked = bookmarkedConditions.some(item => item.name === condition.name);\n    \n    if (isBookmarked) {\n      removeBookmark(condition.name);\n    } else {\n      addBookmark(condition);\n    }\n    \n    return !isBookmarked; // Return new bookmark status\n  }, [bookmarkedConditions, addBookmark, removeBookmark]);\n\n  // Check if a condition is bookmarked\n  const isBookmarked = useCallback((conditionName) => {\n    return bookmarkedConditions.some(item => item.name === conditionName);\n  }, [bookmarkedConditions]);\n\n  // Clear all bookmarks\n  const clearAllBookmarks = useCallback(() => {\n    setBookmarkedConditions([]);\n  }, [setBookmarkedConditions]);\n\n  // Get bookmarks by category\n  const getBookmarksByCategory = useCallback((category) => {\n    return bookmarkedConditions.filter(item => \n      item.category.toLowerCase() === category.toLowerCase()\n    );\n  }, [bookmarkedConditions]);\n\n  // Get bookmark statistics\n  const bookmarkStats = {\n    totalBookmarks: bookmarkedConditions.length,\n    categories: [...new Set(bookmarkedConditions.map(item => item.category))],\n    recentBookmarks: bookmarkedConditions\n      .sort((a, b) => new Date(b.bookmarkedAt) - new Date(a.bookmarkedAt))\n      .slice(0, 5),\n    oldestBookmark: bookmarkedConditions.length > 0 \n      ? bookmarkedConditions.reduce((oldest, current) => \n          new Date(current.bookmarkedAt) < new Date(oldest.bookmarkedAt) ? current : oldest\n        )\n      : null\n  };\n\n  // Export bookmarks as JSON\n  const exportBookmarks = useCallback(() => {\n    const exportData = {\n      bookmarks: bookmarkedConditions,\n      exportDate: new Date().toISOString(),\n      totalCount: bookmarkedConditions.length\n    };\n    \n    return JSON.stringify(exportData, null, 2);\n  }, [bookmarkedConditions]);\n\n  // Import bookmarks from JSON\n  const importBookmarks = useCallback((jsonData, options = { merge: true }) => {\n    try {\n      const importedData = JSON.parse(jsonData);\n      \n      if (!importedData.bookmarks || !Array.isArray(importedData.bookmarks)) {\n        throw new Error('Invalid bookmark data format');\n      }\n      \n      if (options.merge) {\n        // Merge with existing bookmarks, avoiding duplicates\n        setBookmarkedConditions(prev => {\n          const existing = new Set(prev.map(item => item.name));\n          const newBookmarks = importedData.bookmarks.filter(item => !existing.has(item.name));\n          return [...prev, ...newBookmarks];\n        });\n      } else {\n        // Replace all bookmarks\n        setBookmarkedConditions(importedData.bookmarks);\n      }\n      \n      return {\n        success: true,\n        imported: importedData.bookmarks.length,\n        message: `Successfully imported ${importedData.bookmarks.length} bookmarks`\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message,\n        message: 'Failed to import bookmarks'\n      };\n    }\n  }, [setBookmarkedConditions]);\n\n  return {\n    // State\n    bookmarkedConditions,\n    bookmarkStats,\n    \n    // Actions\n    addBookmark,\n    removeBookmark,\n    toggleBookmark,\n    isBookmarked,\n    clearAllBookmarks,\n    getBookmarksByCategory,\n    \n    // Import/Export\n    exportBookmarks,\n    importBookmarks\n  };\n};\n\nexport default useBookmarks;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}