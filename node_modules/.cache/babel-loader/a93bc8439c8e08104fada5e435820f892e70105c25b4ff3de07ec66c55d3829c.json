{"ast":null,"code":"/**\n * Data Indexer\n * Creates reverse indexes and cross-reference maps for multi-dimensional data access\n * Enables efficient lookup of conditions by pathogen, antibiotic, drug class, etc.\n */\n\nimport { processConditionsData } from './dataParser.js';\n\n/**\n * Build comprehensive indexes from processed condition data\n * @param {Array} conditions - Array of medical condition objects\n * @returns {Object} - Complete index structure\n */\nexport const buildIndexes = conditions => {\n  const processedData = processConditionsData(conditions);\n  const indexes = {\n    // Primary data\n    conditions: processedData.conditions,\n    pathogens: processedData.pathogens,\n    antibiotics: processedData.antibiotics,\n    // Reverse indexes\n    pathogenToConditions: new Map(),\n    antibioticToConditions: new Map(),\n    conditionToPathogens: new Map(),\n    conditionToAntibiotics: new Map(),\n    // Classification indexes\n    gramPositivePathogens: [],\n    gramNegativePathogens: [],\n    drugClassToAntibiotics: new Map(),\n    antibioticToDrugClass: new Map(),\n    // Cross-reference maps\n    pathogenAntibioticMatrix: new Map(),\n    conditionComplexity: new Map(),\n    // Statistics\n    stats: {\n      totalConditions: conditions.length,\n      totalPathogens: processedData.totalPathogens,\n      totalAntibiotics: processedData.totalAntibiotics,\n      gramPositiveCount: 0,\n      gramNegativeCount: 0,\n      drugClassCount: 0\n    }\n  };\n\n  // Build pathogen indexes\n  processedData.pathogens.forEach(pathogen => {\n    // Pathogen to conditions mapping\n    indexes.pathogenToConditions.set(pathogen.name, pathogen.conditions);\n\n    // Classify by gram status\n    if (pathogen.gramStatus === 'positive') {\n      indexes.gramPositivePathogens.push(pathogen);\n      indexes.stats.gramPositiveCount++;\n    } else if (pathogen.gramStatus === 'negative') {\n      indexes.gramNegativePathogens.push(pathogen);\n      indexes.stats.gramNegativeCount++;\n    }\n\n    // Build condition to pathogens reverse index\n    pathogen.conditions.forEach(conditionId => {\n      if (!indexes.conditionToPathogens.has(conditionId)) {\n        indexes.conditionToPathogens.set(conditionId, []);\n      }\n      indexes.conditionToPathogens.get(conditionId).push(pathogen.name);\n    });\n  });\n\n  // Build antibiotic indexes\n  processedData.antibiotics.forEach(antibiotic => {\n    // Antibiotic to conditions mapping\n    indexes.antibioticToConditions.set(antibiotic.name, antibiotic.conditions);\n\n    // Drug class classification\n    if (!indexes.drugClassToAntibiotics.has(antibiotic.class)) {\n      indexes.drugClassToAntibiotics.set(antibiotic.class, []);\n    }\n    indexes.drugClassToAntibiotics.get(antibiotic.class).push(antibiotic.name);\n    indexes.antibioticToDrugClass.set(antibiotic.name, antibiotic.class);\n\n    // Build condition to antibiotics reverse index\n    antibiotic.conditions.forEach(conditionId => {\n      if (!indexes.conditionToAntibiotics.has(conditionId)) {\n        indexes.conditionToAntibiotics.set(conditionId, []);\n      }\n      indexes.conditionToAntibiotics.get(conditionId).push(antibiotic.name);\n    });\n  });\n\n  // Build pathogen-antibiotic matrix\n  indexes.pathogenToConditions.forEach((conditionIds, pathogen) => {\n    const antibioticsForPathogen = new Set();\n    conditionIds.forEach(conditionId => {\n      const antibiotics = indexes.conditionToAntibiotics.get(conditionId) || [];\n      antibiotics.forEach(antibiotic => antibioticsForPathogen.add(antibiotic));\n    });\n    indexes.pathogenAntibioticMatrix.set(pathogen, Array.from(antibioticsForPathogen));\n  });\n\n  // Calculate condition complexity scores\n  conditions.forEach(condition => {\n    var _indexes$conditionToP, _indexes$conditionToA;\n    const pathogenCount = ((_indexes$conditionToP = indexes.conditionToPathogens.get(condition.id)) === null || _indexes$conditionToP === void 0 ? void 0 : _indexes$conditionToP.length) || 0;\n    const antibioticCount = ((_indexes$conditionToA = indexes.conditionToAntibiotics.get(condition.id)) === null || _indexes$conditionToA === void 0 ? void 0 : _indexes$conditionToA.length) || 0;\n    const therapyOptions = Object.keys(condition.empiricTherapy || {}).length;\n    const complexityScore = {\n      pathogens: pathogenCount,\n      antibiotics: antibioticCount,\n      therapyOptions: therapyOptions,\n      total: pathogenCount + antibioticCount + therapyOptions\n    };\n    indexes.conditionComplexity.set(condition.id, complexityScore);\n  });\n\n  // Update final statistics\n  indexes.stats.drugClassCount = indexes.drugClassToAntibiotics.size;\n  return indexes;\n};\n\n/**\n * Search pathogens with filtering options\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {Object} options - Search and filter options\n * @returns {Array} - Filtered pathogen results\n */\nexport const searchPathogens = (indexes, options = {}) => {\n  const {\n    query = '',\n    gramStatus = 'all',\n    // 'all', 'positive', 'negative'\n    pathogenType = 'all',\n    // 'all', 'bacteria', 'virus', 'fungus'\n    minConditions = 0,\n    sortBy = 'name' // 'name', 'count', 'conditions'\n  } = options;\n  let results = [...indexes.pathogens];\n\n  // Filter by search query\n  if (query) {\n    const queryLower = query.toLowerCase();\n    results = results.filter(pathogen => pathogen.name.toLowerCase().includes(queryLower) || pathogen.shortName.toLowerCase().includes(queryLower) || pathogen.details.toLowerCase().includes(queryLower));\n  }\n\n  // Filter by gram status\n  if (gramStatus !== 'all') {\n    results = results.filter(pathogen => pathogen.gramStatus === gramStatus);\n  }\n\n  // Filter by pathogen type\n  if (pathogenType !== 'all') {\n    results = results.filter(pathogen => pathogen.type === pathogenType);\n  }\n\n  // Filter by minimum conditions\n  if (minConditions > 0) {\n    results = results.filter(pathogen => pathogen.conditions.length >= minConditions);\n  }\n\n  // Sort results\n  results.sort((a, b) => {\n    switch (sortBy) {\n      case 'count':\n        return b.count - a.count;\n      case 'conditions':\n        return b.conditions.length - a.conditions.length;\n      case 'name':\n      default:\n        return a.name.localeCompare(b.name);\n    }\n  });\n  return results;\n};\n\n/**\n * Search antibiotics with filtering options\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {Object} options - Search and filter options\n * @returns {Array} - Filtered antibiotic results\n */\nexport const searchAntibiotics = (indexes, options = {}) => {\n  const {\n    query = '',\n    drugClass = 'all',\n    minConditions = 0,\n    sortBy = 'name' // 'name', 'count', 'conditions', 'class'\n  } = options;\n  let results = [...indexes.antibiotics];\n\n  // Filter by search query\n  if (query) {\n    const queryLower = query.toLowerCase();\n    results = results.filter(antibiotic => antibiotic.name.toLowerCase().includes(queryLower) || antibiotic.class.toLowerCase().includes(queryLower));\n  }\n\n  // Filter by drug class\n  if (drugClass !== 'all') {\n    results = results.filter(antibiotic => antibiotic.class === drugClass);\n  }\n\n  // Filter by minimum conditions\n  if (minConditions > 0) {\n    results = results.filter(antibiotic => antibiotic.conditions.length >= minConditions);\n  }\n\n  // Sort results\n  results.sort((a, b) => {\n    switch (sortBy) {\n      case 'count':\n        return b.count - a.count;\n      case 'conditions':\n        return b.conditions.length - a.conditions.length;\n      case 'class':\n        return a.class.localeCompare(b.class) || a.name.localeCompare(b.name);\n      case 'name':\n      default:\n        return a.name.localeCompare(b.name);\n    }\n  });\n  return results;\n};\n\n/**\n * Get conditions associated with a specific pathogen\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {string} pathogenName - Name of the pathogen\n * @returns {Array} - Array of condition objects\n */\nexport const getConditionsForPathogen = (indexes, pathogenName) => {\n  const conditionIds = indexes.pathogenToConditions.get(pathogenName) || [];\n  return conditionIds.map(id => indexes.conditions.find(condition => condition.id === id)).filter(Boolean);\n};\n\n/**\n * Get conditions that can be treated with a specific antibiotic\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {string} antibioticName - Name of the antibiotic\n * @returns {Array} - Array of condition objects with therapy context\n */\nexport const getConditionsForAntibiotic = (indexes, antibioticName) => {\n  const conditionIds = indexes.antibioticToConditions.get(antibioticName) || [];\n  const antibiotic = indexes.antibiotics.find(a => a.name === antibioticName);\n  return conditionIds.map(id => {\n    var _antibiotic$therapyCo;\n    const condition = indexes.conditions.find(c => c.id === id);\n    if (!condition) return null;\n\n    // Find specific therapy contexts where this antibiotic is mentioned\n    const relevantTherapies = {};\n    Object.entries(condition.empiricTherapy || {}).forEach(([context, therapy]) => {\n      if (therapy.toLowerCase().includes(antibioticName.toLowerCase())) {\n        relevantTherapies[context] = therapy;\n      }\n    });\n    return {\n      ...condition,\n      relevantTherapies,\n      therapyContexts: (antibiotic === null || antibiotic === void 0 ? void 0 : (_antibiotic$therapyCo = antibiotic.therapyContexts) === null || _antibiotic$therapyCo === void 0 ? void 0 : _antibiotic$therapyCo.filter(ctx => ctx.includes(condition.name))) || []\n    };\n  }).filter(Boolean);\n};\n\n/**\n * Get alternative antibiotics for a specific pathogen\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {string} pathogenName - Name of the pathogen\n * @returns {Array} - Array of antibiotic options with context\n */\nexport const getAntibioticsForPathogen = (indexes, pathogenName) => {\n  const antibioticNames = indexes.pathogenAntibioticMatrix.get(pathogenName) || [];\n  return antibioticNames.map(name => {\n    const antibiotic = indexes.antibiotics.find(a => a.name === name);\n    const conditionIds = indexes.pathogenToConditions.get(pathogenName) || [];\n\n    // Calculate effectiveness score based on how many conditions this antibiotic treats for this pathogen\n    const effectivenessScore = conditionIds.filter(conditionId => antibiotic === null || antibiotic === void 0 ? void 0 : antibiotic.conditions.includes(conditionId)).length;\n    return {\n      ...antibiotic,\n      effectivenessScore,\n      applicableConditions: conditionIds.filter(conditionId => antibiotic === null || antibiotic === void 0 ? void 0 : antibiotic.conditions.includes(conditionId))\n    };\n  }).filter(Boolean).sort((a, b) => b.effectivenessScore - a.effectivenessScore);\n};\n\n/**\n * Find conditions that can be treated with multiple specific antibiotics (combination therapy)\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {Array} antibioticNames - Array of antibiotic names\n * @returns {Array} - Conditions that use these antibiotics together\n */\nexport const findCombinationTherapyConditions = (indexes, antibioticNames) => {\n  const results = [];\n  indexes.conditions.forEach(condition => {\n    Object.entries(condition.empiricTherapy || {}).forEach(([context, therapy]) => {\n      const therapyLower = therapy.toLowerCase();\n      const matchingAntibiotics = antibioticNames.filter(name => therapyLower.includes(name.toLowerCase()));\n      if (matchingAntibiotics.length >= 2) {\n        results.push({\n          condition,\n          context,\n          therapy,\n          matchingAntibiotics\n        });\n      }\n    });\n  });\n  return results;\n};\n\n/**\n * Get drug class statistics\n * @param {Object} indexes - Index structure from buildIndexes\n * @returns {Array} - Array of drug class statistics\n */\nexport const getDrugClassStats = indexes => {\n  const stats = [];\n  indexes.drugClassToAntibiotics.forEach((antibiotics, drugClass) => {\n    const totalConditions = new Set();\n    antibiotics.forEach(antibiotic => {\n      const conditions = indexes.antibioticToConditions.get(antibiotic) || [];\n      conditions.forEach(condition => totalConditions.add(condition));\n    });\n    stats.push({\n      drugClass,\n      antibiotics: antibiotics.length,\n      conditions: totalConditions.size,\n      antibioticList: antibiotics\n    });\n  });\n  return stats.sort((a, b) => b.conditions - a.conditions);\n};\n\n/**\n * Calculate pathogen similarity score based on multiple factors\n * @param {Object} pathogen1 - First pathogen object\n * @param {Object} pathogen2 - Second pathogen object\n * @param {Object} indexes - Index structure from buildIndexes\n * @returns {Object} - Similarity analysis with detailed scores\n */\nexport const calculatePathogenSimilarity = (pathogen1, pathogen2, indexes) => {\n  if (pathogen1.name === pathogen2.name) return {\n    total: 1,\n    factors: {}\n  };\n  const similarity = {\n    total: 0,\n    factors: {\n      gramStatus: 0,\n      pathogenType: 0,\n      sharedConditions: 0,\n      sharedAntibiotics: 0,\n      treatmentComplexity: 0,\n      resistancePattern: 0\n    },\n    details: {\n      sharedConditionNames: [],\n      sharedAntibioticNames: [],\n      uniqueToFirst: [],\n      uniqueToSecond: []\n    }\n  };\n\n  // Gram status similarity (0.15 weight)\n  if (pathogen1.gramStatus === pathogen2.gramStatus && pathogen1.gramStatus !== 'unknown') {\n    similarity.factors.gramStatus = 0.15;\n  }\n\n  // Pathogen type similarity (0.1 weight)\n  if (pathogen1.type === pathogen2.type) {\n    similarity.factors.pathogenType = 0.1;\n  }\n\n  // Shared conditions analysis (0.35 weight)\n  const conditions1 = new Set(pathogen1.conditions);\n  const conditions2 = new Set(pathogen2.conditions);\n  const sharedConditions = [...conditions1].filter(c => conditions2.has(c));\n  const totalUniqueConditions = new Set([...conditions1, ...conditions2]).size;\n  if (totalUniqueConditions > 0) {\n    similarity.factors.sharedConditions = sharedConditions.length / totalUniqueConditions * 0.35;\n    similarity.details.sharedConditionNames = sharedConditions.map(id => {\n      var _indexes$conditions$f;\n      return ((_indexes$conditions$f = indexes.conditions.find(c => c.id === id)) === null || _indexes$conditions$f === void 0 ? void 0 : _indexes$conditions$f.name) || id;\n    });\n  }\n\n  // Shared antibiotics analysis (0.25 weight)\n  const antibiotics1 = new Set(indexes.pathogenAntibioticMatrix.get(pathogen1.name) || []);\n  const antibiotics2 = new Set(indexes.pathogenAntibioticMatrix.get(pathogen2.name) || []);\n  const sharedAntibiotics = [...antibiotics1].filter(a => antibiotics2.has(a));\n  const totalUniqueAntibiotics = new Set([...antibiotics1, ...antibiotics2]).size;\n  if (totalUniqueAntibiotics > 0) {\n    similarity.factors.sharedAntibiotics = sharedAntibiotics.length / totalUniqueAntibiotics * 0.25;\n    similarity.details.sharedAntibioticNames = sharedAntibiotics;\n  }\n\n  // Treatment complexity similarity (0.1 weight)\n  const complexity1 = pathogen1.conditions.reduce((sum, condId) => {\n    const complexity = indexes.conditionComplexity.get(condId);\n    return sum + ((complexity === null || complexity === void 0 ? void 0 : complexity.total) || 0);\n  }, 0);\n  const complexity2 = pathogen2.conditions.reduce((sum, condId) => {\n    const complexity = indexes.conditionComplexity.get(condId);\n    return sum + ((complexity === null || complexity === void 0 ? void 0 : complexity.total) || 0);\n  }, 0);\n  if (complexity1 > 0 && complexity2 > 0) {\n    const complexityDiff = Math.abs(complexity1 - complexity2);\n    const maxComplexity = Math.max(complexity1, complexity2);\n    similarity.factors.treatmentComplexity = Math.max(0, 1 - complexityDiff / maxComplexity) * 0.1;\n  }\n\n  // Resistance pattern similarity (0.05 weight) - placeholder for future enhancement\n  // This could be enhanced with actual resistance data\n  similarity.factors.resistancePattern = 0.05 * Math.random(); // Placeholder\n\n  // Calculate total similarity\n  similarity.total = Object.values(similarity.factors).reduce((sum, score) => sum + score, 0);\n\n  // Add unique condition details\n  similarity.details.uniqueToFirst = [...conditions1].filter(c => !conditions2.has(c)).map(id => {\n    var _indexes$conditions$f2;\n    return ((_indexes$conditions$f2 = indexes.conditions.find(c => c.id === id)) === null || _indexes$conditions$f2 === void 0 ? void 0 : _indexes$conditions$f2.name) || id;\n  });\n  similarity.details.uniqueToSecond = [...conditions2].filter(c => !conditions1.has(c)).map(id => {\n    var _indexes$conditions$f3;\n    return ((_indexes$conditions$f3 = indexes.conditions.find(c => c.id === id)) === null || _indexes$conditions$f3 === void 0 ? void 0 : _indexes$conditions$f3.name) || id;\n  });\n  return similarity;\n};\n\n/**\n * Build comprehensive pathogen relationship network\n * @param {Object} indexes - Index structure from buildIndexes\n * @returns {Object} - Network structure with nodes and weighted edges\n */\nexport const buildPathogenNetwork = indexes => {\n  const network = {\n    nodes: [],\n    edges: [],\n    clusters: new Map(),\n    centralityScores: new Map()\n  };\n\n  // Create nodes for each pathogen\n  indexes.pathogens.forEach(pathogen => {\n    const node = {\n      id: pathogen.name,\n      pathogen: pathogen,\n      connections: 0,\n      centralityScore: 0,\n      clusterData: {\n        gramStatus: pathogen.gramStatus,\n        type: pathogen.type,\n        conditionCount: pathogen.conditions.length\n      }\n    };\n    network.nodes.push(node);\n  });\n\n  // Calculate edges between pathogens based on similarity\n  for (let i = 0; i < indexes.pathogens.length; i++) {\n    for (let j = i + 1; j < indexes.pathogens.length; j++) {\n      const pathogen1 = indexes.pathogens[i];\n      const pathogen2 = indexes.pathogens[j];\n      const similarity = calculatePathogenSimilarity(pathogen1, pathogen2, indexes);\n\n      // Only create edges for meaningful similarities (threshold > 0.2)\n      if (similarity.total > 0.2) {\n        const edge = {\n          source: pathogen1.name,\n          target: pathogen2.name,\n          weight: similarity.total,\n          similarity: similarity,\n          type: similarity.total > 0.6 ? 'strong' : similarity.total > 0.4 ? 'medium' : 'weak'\n        };\n        network.edges.push(edge);\n\n        // Update connection counts\n        const node1 = network.nodes.find(n => n.id === pathogen1.name);\n        const node2 = network.nodes.find(n => n.id === pathogen2.name);\n        if (node1) node1.connections++;\n        if (node2) node2.connections++;\n      }\n    }\n  }\n\n  // Calculate centrality scores (simplified betweenness centrality)\n  network.nodes.forEach(node => {\n    const connections = network.edges.filter(e => e.source === node.id || e.target === node.id);\n    const strongConnections = connections.filter(e => e.type === 'strong').length;\n    const mediumConnections = connections.filter(e => e.type === 'medium').length;\n    const weakConnections = connections.filter(e => e.type === 'weak').length;\n    node.centralityScore = (strongConnections * 3 + mediumConnections * 2 + weakConnections * 1) / network.nodes.length;\n    network.centralityScores.set(node.id, node.centralityScore);\n  });\n\n  // Identify clusters based on gram status and high connectivity\n  const gramClusters = new Map();\n  network.nodes.forEach(node => {\n    const gramStatus = node.clusterData.gramStatus;\n    if (!gramClusters.has(gramStatus)) {\n      gramClusters.set(gramStatus, []);\n    }\n    gramClusters.get(gramStatus).push(node);\n  });\n  network.clusters = gramClusters;\n  return network;\n};\n\n/**\n * Find pathogen exploration paths between two pathogens\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {string} startPathogen - Starting pathogen name\n * @param {string} endPathogen - Target pathogen name\n * @param {number} maxDepth - Maximum path depth to explore\n * @returns {Array} - Array of exploration paths with similarities\n */\nexport const findPathogenPaths = (indexes, startPathogen, endPathogen, maxDepth = 3) => {\n  const network = buildPathogenNetwork(indexes);\n  const paths = [];\n  const findPaths = (current, target, path, depth) => {\n    if (depth > maxDepth) return;\n    if (current === target && path.length > 1) {\n      paths.push([...path]);\n      return;\n    }\n    const edges = network.edges.filter(e => (e.source === current || e.target === current) && !path.includes(e.source === current ? e.target : e.source));\n    edges.forEach(edge => {\n      const next = edge.source === current ? edge.target : edge.source;\n      findPaths(next, target, [...path, next], depth + 1);\n    });\n  };\n  findPaths(startPathogen, endPathogen, [startPathogen], 0);\n\n  // Calculate path scores based on edge weights\n  return paths.map(path => {\n    let totalScore = 0;\n    let pathDetails = [];\n    for (let i = 0; i < path.length - 1; i++) {\n      const edge = network.edges.find(e => e.source === path[i] && e.target === path[i + 1] || e.source === path[i + 1] && e.target === path[i]);\n      if (edge) {\n        totalScore += edge.weight;\n        pathDetails.push({\n          from: path[i],\n          to: path[i + 1],\n          similarity: edge.similarity,\n          weight: edge.weight\n        });\n      }\n    }\n    return {\n      path,\n      score: totalScore / (path.length - 1),\n      // Average similarity along path\n      details: pathDetails,\n      length: path.length\n    };\n  }).sort((a, b) => b.score - a.score);\n};\n\n/**\n * Get pathogen recommendations based on current selection and user behavior\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {string} currentPathogen - Currently selected pathogen\n * @param {Array} recentlyViewed - Array of recently viewed pathogen names\n * @param {Object} preferences - User learning preferences\n * @returns {Array} - Array of recommended pathogens with reasoning\n */\nexport const getPathogenRecommendations = (indexes, currentPathogen, recentlyViewed = [], preferences = {}) => {\n  const network = buildPathogenNetwork(indexes);\n  const recommendations = [];\n  const currentNode = network.nodes.find(n => n.id === currentPathogen);\n  if (!currentNode) return recommendations;\n\n  // Get direct connections sorted by similarity\n  const directConnections = network.edges.filter(e => e.source === currentPathogen || e.target === currentPathogen).map(e => ({\n    pathogen: e.source === currentPathogen ? e.target : e.source,\n    similarity: e.similarity,\n    weight: e.weight,\n    reasoning: 'Direct similarity connection'\n  })).sort((a, b) => b.weight - a.weight).slice(0, 5);\n  recommendations.push(...directConnections);\n\n  // Get pathogens from same gram status if user prefers systematic learning\n  if (preferences.systematicLearning && currentNode.clusterData.gramStatus !== 'unknown') {\n    const sameGramPathogens = indexes.pathogens.filter(p => p.gramStatus === currentNode.clusterData.gramStatus && p.name !== currentPathogen && !recommendations.some(r => r.pathogen === p.name)).slice(0, 3).map(p => ({\n      pathogen: p.name,\n      similarity: {\n        total: 0.3,\n        factors: {\n          gramStatus: 0.15\n        }\n      },\n      weight: 0.3,\n      reasoning: `Same gram status (${p.gramStatus})`\n    }));\n    recommendations.push(...sameGramPathogens);\n  }\n\n  // Get pathogens that treat similar conditions\n  const currentConditions = new Set(currentNode.pathogen.conditions);\n  const conditionBasedRecommendations = indexes.pathogens.filter(p => {\n    if (p.name === currentPathogen) return false;\n    if (recommendations.some(r => r.pathogen === p.name)) return false;\n    const sharedConditions = p.conditions.filter(c => currentConditions.has(c));\n    return sharedConditions.length > 0;\n  }).map(p => {\n    const sharedConditions = p.conditions.filter(c => currentConditions.has(c));\n    const weight = sharedConditions.length / Math.max(currentConditions.size, p.conditions.length);\n    return {\n      pathogen: p.name,\n      similarity: {\n        total: weight,\n        factors: {\n          sharedConditions: weight\n        }\n      },\n      weight: weight,\n      reasoning: `Treats similar conditions (${sharedConditions.length} shared)`\n    };\n  }).sort((a, b) => b.weight - a.weight).slice(0, 3);\n  recommendations.push(...conditionBasedRecommendations);\n\n  // Avoid recently viewed unless specifically requested\n  if (!preferences.includeRecentlyViewed) {\n    return recommendations.filter(r => !recentlyViewed.includes(r.pathogen));\n  }\n  return recommendations.slice(0, 8); // Limit to top 8 recommendations\n};","map":{"version":3,"names":["processConditionsData","buildIndexes","conditions","processedData","indexes","pathogens","antibiotics","pathogenToConditions","Map","antibioticToConditions","conditionToPathogens","conditionToAntibiotics","gramPositivePathogens","gramNegativePathogens","drugClassToAntibiotics","antibioticToDrugClass","pathogenAntibioticMatrix","conditionComplexity","stats","totalConditions","length","totalPathogens","totalAntibiotics","gramPositiveCount","gramNegativeCount","drugClassCount","forEach","pathogen","set","name","gramStatus","push","conditionId","has","get","antibiotic","class","conditionIds","antibioticsForPathogen","Set","add","Array","from","condition","_indexes$conditionToP","_indexes$conditionToA","pathogenCount","id","antibioticCount","therapyOptions","Object","keys","empiricTherapy","complexityScore","total","size","searchPathogens","options","query","pathogenType","minConditions","sortBy","results","queryLower","toLowerCase","filter","includes","shortName","details","type","sort","a","b","count","localeCompare","searchAntibiotics","drugClass","getConditionsForPathogen","pathogenName","map","find","Boolean","getConditionsForAntibiotic","antibioticName","_antibiotic$therapyCo","c","relevantTherapies","entries","context","therapy","therapyContexts","ctx","getAntibioticsForPathogen","antibioticNames","effectivenessScore","applicableConditions","findCombinationTherapyConditions","therapyLower","matchingAntibiotics","getDrugClassStats","antibioticList","calculatePathogenSimilarity","pathogen1","pathogen2","factors","similarity","sharedConditions","sharedAntibiotics","treatmentComplexity","resistancePattern","sharedConditionNames","sharedAntibioticNames","uniqueToFirst","uniqueToSecond","conditions1","conditions2","totalUniqueConditions","_indexes$conditions$f","antibiotics1","antibiotics2","totalUniqueAntibiotics","complexity1","reduce","sum","condId","complexity","complexity2","complexityDiff","Math","abs","maxComplexity","max","random","values","score","_indexes$conditions$f2","_indexes$conditions$f3","buildPathogenNetwork","network","nodes","edges","clusters","centralityScores","node","connections","centralityScore","clusterData","conditionCount","i","j","edge","source","target","weight","node1","n","node2","e","strongConnections","mediumConnections","weakConnections","gramClusters","findPathogenPaths","startPathogen","endPathogen","maxDepth","paths","findPaths","current","path","depth","next","totalScore","pathDetails","to","getPathogenRecommendations","currentPathogen","recentlyViewed","preferences","recommendations","currentNode","directConnections","reasoning","slice","systematicLearning","sameGramPathogens","p","some","r","currentConditions","conditionBasedRecommendations","includeRecentlyViewed"],"sources":["/Users/joshpankin/My Drive/Obsidian/1. Projects/Antibiotic Learning app/src/utils/dataIndexer.js"],"sourcesContent":["/**\n * Data Indexer\n * Creates reverse indexes and cross-reference maps for multi-dimensional data access\n * Enables efficient lookup of conditions by pathogen, antibiotic, drug class, etc.\n */\n\nimport { processConditionsData } from './dataParser.js';\n\n/**\n * Build comprehensive indexes from processed condition data\n * @param {Array} conditions - Array of medical condition objects\n * @returns {Object} - Complete index structure\n */\nexport const buildIndexes = (conditions) => {\n  const processedData = processConditionsData(conditions);\n  \n  const indexes = {\n    // Primary data\n    conditions: processedData.conditions,\n    pathogens: processedData.pathogens,\n    antibiotics: processedData.antibiotics,\n    \n    // Reverse indexes\n    pathogenToConditions: new Map(),\n    antibioticToConditions: new Map(),\n    conditionToPathogens: new Map(),\n    conditionToAntibiotics: new Map(),\n    \n    // Classification indexes\n    gramPositivePathogens: [],\n    gramNegativePathogens: [],\n    drugClassToAntibiotics: new Map(),\n    antibioticToDrugClass: new Map(),\n    \n    // Cross-reference maps\n    pathogenAntibioticMatrix: new Map(),\n    conditionComplexity: new Map(),\n    \n    // Statistics\n    stats: {\n      totalConditions: conditions.length,\n      totalPathogens: processedData.totalPathogens,\n      totalAntibiotics: processedData.totalAntibiotics,\n      gramPositiveCount: 0,\n      gramNegativeCount: 0,\n      drugClassCount: 0\n    }\n  };\n  \n  // Build pathogen indexes\n  processedData.pathogens.forEach(pathogen => {\n    // Pathogen to conditions mapping\n    indexes.pathogenToConditions.set(pathogen.name, pathogen.conditions);\n    \n    // Classify by gram status\n    if (pathogen.gramStatus === 'positive') {\n      indexes.gramPositivePathogens.push(pathogen);\n      indexes.stats.gramPositiveCount++;\n    } else if (pathogen.gramStatus === 'negative') {\n      indexes.gramNegativePathogens.push(pathogen);\n      indexes.stats.gramNegativeCount++;\n    }\n    \n    // Build condition to pathogens reverse index\n    pathogen.conditions.forEach(conditionId => {\n      if (!indexes.conditionToPathogens.has(conditionId)) {\n        indexes.conditionToPathogens.set(conditionId, []);\n      }\n      indexes.conditionToPathogens.get(conditionId).push(pathogen.name);\n    });\n  });\n  \n  // Build antibiotic indexes\n  processedData.antibiotics.forEach(antibiotic => {\n    // Antibiotic to conditions mapping\n    indexes.antibioticToConditions.set(antibiotic.name, antibiotic.conditions);\n    \n    // Drug class classification\n    if (!indexes.drugClassToAntibiotics.has(antibiotic.class)) {\n      indexes.drugClassToAntibiotics.set(antibiotic.class, []);\n    }\n    indexes.drugClassToAntibiotics.get(antibiotic.class).push(antibiotic.name);\n    indexes.antibioticToDrugClass.set(antibiotic.name, antibiotic.class);\n    \n    // Build condition to antibiotics reverse index\n    antibiotic.conditions.forEach(conditionId => {\n      if (!indexes.conditionToAntibiotics.has(conditionId)) {\n        indexes.conditionToAntibiotics.set(conditionId, []);\n      }\n      indexes.conditionToAntibiotics.get(conditionId).push(antibiotic.name);\n    });\n  });\n  \n  // Build pathogen-antibiotic matrix\n  indexes.pathogenToConditions.forEach((conditionIds, pathogen) => {\n    const antibioticsForPathogen = new Set();\n    \n    conditionIds.forEach(conditionId => {\n      const antibiotics = indexes.conditionToAntibiotics.get(conditionId) || [];\n      antibiotics.forEach(antibiotic => antibioticsForPathogen.add(antibiotic));\n    });\n    \n    indexes.pathogenAntibioticMatrix.set(pathogen, Array.from(antibioticsForPathogen));\n  });\n  \n  // Calculate condition complexity scores\n  conditions.forEach(condition => {\n    const pathogenCount = indexes.conditionToPathogens.get(condition.id)?.length || 0;\n    const antibioticCount = indexes.conditionToAntibiotics.get(condition.id)?.length || 0;\n    const therapyOptions = Object.keys(condition.empiricTherapy || {}).length;\n    \n    const complexityScore = {\n      pathogens: pathogenCount,\n      antibiotics: antibioticCount,\n      therapyOptions: therapyOptions,\n      total: pathogenCount + antibioticCount + therapyOptions\n    };\n    \n    indexes.conditionComplexity.set(condition.id, complexityScore);\n  });\n  \n  // Update final statistics\n  indexes.stats.drugClassCount = indexes.drugClassToAntibiotics.size;\n  \n  return indexes;\n};\n\n/**\n * Search pathogens with filtering options\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {Object} options - Search and filter options\n * @returns {Array} - Filtered pathogen results\n */\nexport const searchPathogens = (indexes, options = {}) => {\n  const {\n    query = '',\n    gramStatus = 'all', // 'all', 'positive', 'negative'\n    pathogenType = 'all', // 'all', 'bacteria', 'virus', 'fungus'\n    minConditions = 0,\n    sortBy = 'name' // 'name', 'count', 'conditions'\n  } = options;\n  \n  let results = [...indexes.pathogens];\n  \n  // Filter by search query\n  if (query) {\n    const queryLower = query.toLowerCase();\n    results = results.filter(pathogen => \n      pathogen.name.toLowerCase().includes(queryLower) ||\n      pathogen.shortName.toLowerCase().includes(queryLower) ||\n      pathogen.details.toLowerCase().includes(queryLower)\n    );\n  }\n  \n  // Filter by gram status\n  if (gramStatus !== 'all') {\n    results = results.filter(pathogen => pathogen.gramStatus === gramStatus);\n  }\n  \n  // Filter by pathogen type\n  if (pathogenType !== 'all') {\n    results = results.filter(pathogen => pathogen.type === pathogenType);\n  }\n  \n  // Filter by minimum conditions\n  if (minConditions > 0) {\n    results = results.filter(pathogen => pathogen.conditions.length >= minConditions);\n  }\n  \n  // Sort results\n  results.sort((a, b) => {\n    switch (sortBy) {\n      case 'count':\n        return b.count - a.count;\n      case 'conditions':\n        return b.conditions.length - a.conditions.length;\n      case 'name':\n      default:\n        return a.name.localeCompare(b.name);\n    }\n  });\n  \n  return results;\n};\n\n/**\n * Search antibiotics with filtering options\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {Object} options - Search and filter options\n * @returns {Array} - Filtered antibiotic results\n */\nexport const searchAntibiotics = (indexes, options = {}) => {\n  const {\n    query = '',\n    drugClass = 'all',\n    minConditions = 0,\n    sortBy = 'name' // 'name', 'count', 'conditions', 'class'\n  } = options;\n  \n  let results = [...indexes.antibiotics];\n  \n  // Filter by search query\n  if (query) {\n    const queryLower = query.toLowerCase();\n    results = results.filter(antibiotic => \n      antibiotic.name.toLowerCase().includes(queryLower) ||\n      antibiotic.class.toLowerCase().includes(queryLower)\n    );\n  }\n  \n  // Filter by drug class\n  if (drugClass !== 'all') {\n    results = results.filter(antibiotic => antibiotic.class === drugClass);\n  }\n  \n  // Filter by minimum conditions\n  if (minConditions > 0) {\n    results = results.filter(antibiotic => antibiotic.conditions.length >= minConditions);\n  }\n  \n  // Sort results\n  results.sort((a, b) => {\n    switch (sortBy) {\n      case 'count':\n        return b.count - a.count;\n      case 'conditions':\n        return b.conditions.length - a.conditions.length;\n      case 'class':\n        return a.class.localeCompare(b.class) || a.name.localeCompare(b.name);\n      case 'name':\n      default:\n        return a.name.localeCompare(b.name);\n    }\n  });\n  \n  return results;\n};\n\n/**\n * Get conditions associated with a specific pathogen\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {string} pathogenName - Name of the pathogen\n * @returns {Array} - Array of condition objects\n */\nexport const getConditionsForPathogen = (indexes, pathogenName) => {\n  const conditionIds = indexes.pathogenToConditions.get(pathogenName) || [];\n  return conditionIds.map(id => \n    indexes.conditions.find(condition => condition.id === id)\n  ).filter(Boolean);\n};\n\n/**\n * Get conditions that can be treated with a specific antibiotic\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {string} antibioticName - Name of the antibiotic\n * @returns {Array} - Array of condition objects with therapy context\n */\nexport const getConditionsForAntibiotic = (indexes, antibioticName) => {\n  const conditionIds = indexes.antibioticToConditions.get(antibioticName) || [];\n  const antibiotic = indexes.antibiotics.find(a => a.name === antibioticName);\n  \n  return conditionIds.map(id => {\n    const condition = indexes.conditions.find(c => c.id === id);\n    if (!condition) return null;\n    \n    // Find specific therapy contexts where this antibiotic is mentioned\n    const relevantTherapies = {};\n    Object.entries(condition.empiricTherapy || {}).forEach(([context, therapy]) => {\n      if (therapy.toLowerCase().includes(antibioticName.toLowerCase())) {\n        relevantTherapies[context] = therapy;\n      }\n    });\n    \n    return {\n      ...condition,\n      relevantTherapies,\n      therapyContexts: antibiotic?.therapyContexts?.filter(ctx => \n        ctx.includes(condition.name)\n      ) || []\n    };\n  }).filter(Boolean);\n};\n\n/**\n * Get alternative antibiotics for a specific pathogen\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {string} pathogenName - Name of the pathogen\n * @returns {Array} - Array of antibiotic options with context\n */\nexport const getAntibioticsForPathogen = (indexes, pathogenName) => {\n  const antibioticNames = indexes.pathogenAntibioticMatrix.get(pathogenName) || [];\n  \n  return antibioticNames.map(name => {\n    const antibiotic = indexes.antibiotics.find(a => a.name === name);\n    const conditionIds = indexes.pathogenToConditions.get(pathogenName) || [];\n    \n    // Calculate effectiveness score based on how many conditions this antibiotic treats for this pathogen\n    const effectivenessScore = conditionIds.filter(conditionId => \n      antibiotic?.conditions.includes(conditionId)\n    ).length;\n    \n    return {\n      ...antibiotic,\n      effectivenessScore,\n      applicableConditions: conditionIds.filter(conditionId => \n        antibiotic?.conditions.includes(conditionId)\n      )\n    };\n  }).filter(Boolean).sort((a, b) => b.effectivenessScore - a.effectivenessScore);\n};\n\n/**\n * Find conditions that can be treated with multiple specific antibiotics (combination therapy)\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {Array} antibioticNames - Array of antibiotic names\n * @returns {Array} - Conditions that use these antibiotics together\n */\nexport const findCombinationTherapyConditions = (indexes, antibioticNames) => {\n  const results = [];\n  \n  indexes.conditions.forEach(condition => {\n    Object.entries(condition.empiricTherapy || {}).forEach(([context, therapy]) => {\n      const therapyLower = therapy.toLowerCase();\n      const matchingAntibiotics = antibioticNames.filter(name => \n        therapyLower.includes(name.toLowerCase())\n      );\n      \n      if (matchingAntibiotics.length >= 2) {\n        results.push({\n          condition,\n          context,\n          therapy,\n          matchingAntibiotics\n        });\n      }\n    });\n  });\n  \n  return results;\n};\n\n/**\n * Get drug class statistics\n * @param {Object} indexes - Index structure from buildIndexes\n * @returns {Array} - Array of drug class statistics\n */\nexport const getDrugClassStats = (indexes) => {\n  const stats = [];\n  \n  indexes.drugClassToAntibiotics.forEach((antibiotics, drugClass) => {\n    const totalConditions = new Set();\n    antibiotics.forEach(antibiotic => {\n      const conditions = indexes.antibioticToConditions.get(antibiotic) || [];\n      conditions.forEach(condition => totalConditions.add(condition));\n    });\n    \n    stats.push({\n      drugClass,\n      antibiotics: antibiotics.length,\n      conditions: totalConditions.size,\n      antibioticList: antibiotics\n    });\n  });\n  \n  return stats.sort((a, b) => b.conditions - a.conditions);\n};\n\n/**\n * Calculate pathogen similarity score based on multiple factors\n * @param {Object} pathogen1 - First pathogen object\n * @param {Object} pathogen2 - Second pathogen object\n * @param {Object} indexes - Index structure from buildIndexes\n * @returns {Object} - Similarity analysis with detailed scores\n */\nexport const calculatePathogenSimilarity = (pathogen1, pathogen2, indexes) => {\n  if (pathogen1.name === pathogen2.name) return { total: 1, factors: {} };\n  \n  const similarity = {\n    total: 0,\n    factors: {\n      gramStatus: 0,\n      pathogenType: 0,\n      sharedConditions: 0,\n      sharedAntibiotics: 0,\n      treatmentComplexity: 0,\n      resistancePattern: 0\n    },\n    details: {\n      sharedConditionNames: [],\n      sharedAntibioticNames: [],\n      uniqueToFirst: [],\n      uniqueToSecond: []\n    }\n  };\n  \n  // Gram status similarity (0.15 weight)\n  if (pathogen1.gramStatus === pathogen2.gramStatus && pathogen1.gramStatus !== 'unknown') {\n    similarity.factors.gramStatus = 0.15;\n  }\n  \n  // Pathogen type similarity (0.1 weight)\n  if (pathogen1.type === pathogen2.type) {\n    similarity.factors.pathogenType = 0.1;\n  }\n  \n  // Shared conditions analysis (0.35 weight)\n  const conditions1 = new Set(pathogen1.conditions);\n  const conditions2 = new Set(pathogen2.conditions);\n  const sharedConditions = [...conditions1].filter(c => conditions2.has(c));\n  const totalUniqueConditions = new Set([...conditions1, ...conditions2]).size;\n  \n  if (totalUniqueConditions > 0) {\n    similarity.factors.sharedConditions = (sharedConditions.length / totalUniqueConditions) * 0.35;\n    similarity.details.sharedConditionNames = sharedConditions.map(id => \n      indexes.conditions.find(c => c.id === id)?.name || id\n    );\n  }\n  \n  // Shared antibiotics analysis (0.25 weight)\n  const antibiotics1 = new Set(indexes.pathogenAntibioticMatrix.get(pathogen1.name) || []);\n  const antibiotics2 = new Set(indexes.pathogenAntibioticMatrix.get(pathogen2.name) || []);\n  const sharedAntibiotics = [...antibiotics1].filter(a => antibiotics2.has(a));\n  const totalUniqueAntibiotics = new Set([...antibiotics1, ...antibiotics2]).size;\n  \n  if (totalUniqueAntibiotics > 0) {\n    similarity.factors.sharedAntibiotics = (sharedAntibiotics.length / totalUniqueAntibiotics) * 0.25;\n    similarity.details.sharedAntibioticNames = sharedAntibiotics;\n  }\n  \n  // Treatment complexity similarity (0.1 weight)\n  const complexity1 = pathogen1.conditions.reduce((sum, condId) => {\n    const complexity = indexes.conditionComplexity.get(condId);\n    return sum + (complexity?.total || 0);\n  }, 0);\n  const complexity2 = pathogen2.conditions.reduce((sum, condId) => {\n    const complexity = indexes.conditionComplexity.get(condId);\n    return sum + (complexity?.total || 0);\n  }, 0);\n  \n  if (complexity1 > 0 && complexity2 > 0) {\n    const complexityDiff = Math.abs(complexity1 - complexity2);\n    const maxComplexity = Math.max(complexity1, complexity2);\n    similarity.factors.treatmentComplexity = Math.max(0, (1 - complexityDiff / maxComplexity)) * 0.1;\n  }\n  \n  // Resistance pattern similarity (0.05 weight) - placeholder for future enhancement\n  // This could be enhanced with actual resistance data\n  similarity.factors.resistancePattern = 0.05 * Math.random(); // Placeholder\n  \n  // Calculate total similarity\n  similarity.total = Object.values(similarity.factors).reduce((sum, score) => sum + score, 0);\n  \n  // Add unique condition details\n  similarity.details.uniqueToFirst = [...conditions1].filter(c => !conditions2.has(c))\n    .map(id => indexes.conditions.find(c => c.id === id)?.name || id);\n  similarity.details.uniqueToSecond = [...conditions2].filter(c => !conditions1.has(c))\n    .map(id => indexes.conditions.find(c => c.id === id)?.name || id);\n  \n  return similarity;\n};\n\n/**\n * Build comprehensive pathogen relationship network\n * @param {Object} indexes - Index structure from buildIndexes\n * @returns {Object} - Network structure with nodes and weighted edges\n */\nexport const buildPathogenNetwork = (indexes) => {\n  const network = {\n    nodes: [],\n    edges: [],\n    clusters: new Map(),\n    centralityScores: new Map()\n  };\n  \n  // Create nodes for each pathogen\n  indexes.pathogens.forEach(pathogen => {\n    const node = {\n      id: pathogen.name,\n      pathogen: pathogen,\n      connections: 0,\n      centralityScore: 0,\n      clusterData: {\n        gramStatus: pathogen.gramStatus,\n        type: pathogen.type,\n        conditionCount: pathogen.conditions.length\n      }\n    };\n    network.nodes.push(node);\n  });\n  \n  // Calculate edges between pathogens based on similarity\n  for (let i = 0; i < indexes.pathogens.length; i++) {\n    for (let j = i + 1; j < indexes.pathogens.length; j++) {\n      const pathogen1 = indexes.pathogens[i];\n      const pathogen2 = indexes.pathogens[j];\n      const similarity = calculatePathogenSimilarity(pathogen1, pathogen2, indexes);\n      \n      // Only create edges for meaningful similarities (threshold > 0.2)\n      if (similarity.total > 0.2) {\n        const edge = {\n          source: pathogen1.name,\n          target: pathogen2.name,\n          weight: similarity.total,\n          similarity: similarity,\n          type: similarity.total > 0.6 ? 'strong' : similarity.total > 0.4 ? 'medium' : 'weak'\n        };\n        \n        network.edges.push(edge);\n        \n        // Update connection counts\n        const node1 = network.nodes.find(n => n.id === pathogen1.name);\n        const node2 = network.nodes.find(n => n.id === pathogen2.name);\n        if (node1) node1.connections++;\n        if (node2) node2.connections++;\n      }\n    }\n  }\n  \n  // Calculate centrality scores (simplified betweenness centrality)\n  network.nodes.forEach(node => {\n    const connections = network.edges.filter(e => e.source === node.id || e.target === node.id);\n    const strongConnections = connections.filter(e => e.type === 'strong').length;\n    const mediumConnections = connections.filter(e => e.type === 'medium').length;\n    const weakConnections = connections.filter(e => e.type === 'weak').length;\n    \n    node.centralityScore = (strongConnections * 3 + mediumConnections * 2 + weakConnections * 1) / network.nodes.length;\n    network.centralityScores.set(node.id, node.centralityScore);\n  });\n  \n  // Identify clusters based on gram status and high connectivity\n  const gramClusters = new Map();\n  network.nodes.forEach(node => {\n    const gramStatus = node.clusterData.gramStatus;\n    if (!gramClusters.has(gramStatus)) {\n      gramClusters.set(gramStatus, []);\n    }\n    gramClusters.get(gramStatus).push(node);\n  });\n  \n  network.clusters = gramClusters;\n  \n  return network;\n};\n\n/**\n * Find pathogen exploration paths between two pathogens\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {string} startPathogen - Starting pathogen name\n * @param {string} endPathogen - Target pathogen name\n * @param {number} maxDepth - Maximum path depth to explore\n * @returns {Array} - Array of exploration paths with similarities\n */\nexport const findPathogenPaths = (indexes, startPathogen, endPathogen, maxDepth = 3) => {\n  const network = buildPathogenNetwork(indexes);\n  const paths = [];\n  \n  const findPaths = (current, target, path, depth) => {\n    if (depth > maxDepth) return;\n    if (current === target && path.length > 1) {\n      paths.push([...path]);\n      return;\n    }\n    \n    const edges = network.edges.filter(e => \n      (e.source === current || e.target === current) && \n      !path.includes(e.source === current ? e.target : e.source)\n    );\n    \n    edges.forEach(edge => {\n      const next = edge.source === current ? edge.target : edge.source;\n      findPaths(next, target, [...path, next], depth + 1);\n    });\n  };\n  \n  findPaths(startPathogen, endPathogen, [startPathogen], 0);\n  \n  // Calculate path scores based on edge weights\n  return paths.map(path => {\n    let totalScore = 0;\n    let pathDetails = [];\n    \n    for (let i = 0; i < path.length - 1; i++) {\n      const edge = network.edges.find(e => \n        (e.source === path[i] && e.target === path[i + 1]) ||\n        (e.source === path[i + 1] && e.target === path[i])\n      );\n      \n      if (edge) {\n        totalScore += edge.weight;\n        pathDetails.push({\n          from: path[i],\n          to: path[i + 1],\n          similarity: edge.similarity,\n          weight: edge.weight\n        });\n      }\n    }\n    \n    return {\n      path,\n      score: totalScore / (path.length - 1), // Average similarity along path\n      details: pathDetails,\n      length: path.length\n    };\n  }).sort((a, b) => b.score - a.score);\n};\n\n/**\n * Get pathogen recommendations based on current selection and user behavior\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {string} currentPathogen - Currently selected pathogen\n * @param {Array} recentlyViewed - Array of recently viewed pathogen names\n * @param {Object} preferences - User learning preferences\n * @returns {Array} - Array of recommended pathogens with reasoning\n */\nexport const getPathogenRecommendations = (indexes, currentPathogen, recentlyViewed = [], preferences = {}) => {\n  const network = buildPathogenNetwork(indexes);\n  const recommendations = [];\n  \n  const currentNode = network.nodes.find(n => n.id === currentPathogen);\n  if (!currentNode) return recommendations;\n  \n  // Get direct connections sorted by similarity\n  const directConnections = network.edges\n    .filter(e => e.source === currentPathogen || e.target === currentPathogen)\n    .map(e => ({\n      pathogen: e.source === currentPathogen ? e.target : e.source,\n      similarity: e.similarity,\n      weight: e.weight,\n      reasoning: 'Direct similarity connection'\n    }))\n    .sort((a, b) => b.weight - a.weight)\n    .slice(0, 5);\n  \n  recommendations.push(...directConnections);\n  \n  // Get pathogens from same gram status if user prefers systematic learning\n  if (preferences.systematicLearning && currentNode.clusterData.gramStatus !== 'unknown') {\n    const sameGramPathogens = indexes.pathogens\n      .filter(p => \n        p.gramStatus === currentNode.clusterData.gramStatus && \n        p.name !== currentPathogen &&\n        !recommendations.some(r => r.pathogen === p.name)\n      )\n      .slice(0, 3)\n      .map(p => ({\n        pathogen: p.name,\n        similarity: { total: 0.3, factors: { gramStatus: 0.15 } },\n        weight: 0.3,\n        reasoning: `Same gram status (${p.gramStatus})`\n      }));\n    \n    recommendations.push(...sameGramPathogens);\n  }\n  \n  // Get pathogens that treat similar conditions\n  const currentConditions = new Set(currentNode.pathogen.conditions);\n  const conditionBasedRecommendations = indexes.pathogens\n    .filter(p => {\n      if (p.name === currentPathogen) return false;\n      if (recommendations.some(r => r.pathogen === p.name)) return false;\n      \n      const sharedConditions = p.conditions.filter(c => currentConditions.has(c));\n      return sharedConditions.length > 0;\n    })\n    .map(p => {\n      const sharedConditions = p.conditions.filter(c => currentConditions.has(c));\n      const weight = sharedConditions.length / Math.max(currentConditions.size, p.conditions.length);\n      \n      return {\n        pathogen: p.name,\n        similarity: { total: weight, factors: { sharedConditions: weight } },\n        weight: weight,\n        reasoning: `Treats similar conditions (${sharedConditions.length} shared)`\n      };\n    })\n    .sort((a, b) => b.weight - a.weight)\n    .slice(0, 3);\n  \n  recommendations.push(...conditionBasedRecommendations);\n  \n  // Avoid recently viewed unless specifically requested\n  if (!preferences.includeRecentlyViewed) {\n    return recommendations.filter(r => !recentlyViewed.includes(r.pathogen));\n  }\n  \n  return recommendations.slice(0, 8); // Limit to top 8 recommendations\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}