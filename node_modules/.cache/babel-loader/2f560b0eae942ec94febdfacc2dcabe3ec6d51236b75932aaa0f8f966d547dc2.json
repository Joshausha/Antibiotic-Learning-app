{"ast":null,"code":"import _objectSpread from\"/Users/joshpankin/My Drive/Obsidian/1. Projects/Antibiotic Learning app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";/**\n * Data Indexer\n * Creates reverse indexes and cross-reference maps for multi-dimensional data access\n * Enables efficient lookup of conditions by pathogen, antibiotic, drug class, etc.\n */import{processConditionsData}from'./dataParser.js';/**\n * Build comprehensive indexes from processed condition data\n * @param {Array} conditions - Array of medical condition objects\n * @returns {Object} - Complete index structure\n */export const buildIndexes=conditions=>{const processedData=processConditionsData(conditions);const indexes={// Primary data\nconditions:processedData.conditions,pathogens:processedData.pathogens,antibiotics:processedData.antibiotics,// Reverse indexes\npathogenToConditions:new Map(),antibioticToConditions:new Map(),conditionToPathogens:new Map(),conditionToAntibiotics:new Map(),// Classification indexes\ngramPositivePathogens:[],gramNegativePathogens:[],drugClassToAntibiotics:new Map(),antibioticToDrugClass:new Map(),// Cross-reference maps\npathogenAntibioticMatrix:new Map(),conditionComplexity:new Map(),// Statistics\nstats:{totalConditions:conditions.length,totalPathogens:processedData.totalPathogens,totalAntibiotics:processedData.totalAntibiotics,gramPositiveCount:0,gramNegativeCount:0,drugClassCount:0}};// Build pathogen indexes\nprocessedData.pathogens.forEach(pathogen=>{// Pathogen to conditions mapping\nindexes.pathogenToConditions.set(pathogen.name,pathogen.conditions);// Classify by gram status\nif(pathogen.gramStatus==='positive'){indexes.gramPositivePathogens.push(pathogen);indexes.stats.gramPositiveCount++;}else if(pathogen.gramStatus==='negative'){indexes.gramNegativePathogens.push(pathogen);indexes.stats.gramNegativeCount++;}// Build condition to pathogens reverse index\npathogen.conditions.forEach(conditionId=>{if(!indexes.conditionToPathogens.has(conditionId)){indexes.conditionToPathogens.set(conditionId,[]);}indexes.conditionToPathogens.get(conditionId).push(pathogen.name);});});// Build antibiotic indexes\nprocessedData.antibiotics.forEach(antibiotic=>{// Antibiotic to conditions mapping\nindexes.antibioticToConditions.set(antibiotic.name,antibiotic.conditions);// Drug class classification\nif(!indexes.drugClassToAntibiotics.has(antibiotic.class)){indexes.drugClassToAntibiotics.set(antibiotic.class,[]);}indexes.drugClassToAntibiotics.get(antibiotic.class).push(antibiotic.name);indexes.antibioticToDrugClass.set(antibiotic.name,antibiotic.class);// Build condition to antibiotics reverse index\nantibiotic.conditions.forEach(conditionId=>{if(!indexes.conditionToAntibiotics.has(conditionId)){indexes.conditionToAntibiotics.set(conditionId,[]);}indexes.conditionToAntibiotics.get(conditionId).push(antibiotic.name);});});// Build pathogen-antibiotic matrix\nindexes.pathogenToConditions.forEach((conditionIds,pathogen)=>{const antibioticsForPathogen=new Set();conditionIds.forEach(conditionId=>{const antibiotics=indexes.conditionToAntibiotics.get(conditionId)||[];antibiotics.forEach(antibiotic=>antibioticsForPathogen.add(antibiotic));});indexes.pathogenAntibioticMatrix.set(pathogen,Array.from(antibioticsForPathogen));});// Calculate condition complexity scores\nconditions.forEach(condition=>{var _indexes$conditionToP,_indexes$conditionToA;const pathogenCount=((_indexes$conditionToP=indexes.conditionToPathogens.get(condition.id))===null||_indexes$conditionToP===void 0?void 0:_indexes$conditionToP.length)||0;const antibioticCount=((_indexes$conditionToA=indexes.conditionToAntibiotics.get(condition.id))===null||_indexes$conditionToA===void 0?void 0:_indexes$conditionToA.length)||0;const therapyOptions=Object.keys(condition.empiricTherapy||{}).length;const complexityScore={pathogens:pathogenCount,antibiotics:antibioticCount,therapyOptions:therapyOptions,total:pathogenCount+antibioticCount+therapyOptions};indexes.conditionComplexity.set(condition.id,complexityScore);});// Update final statistics\nindexes.stats.drugClassCount=indexes.drugClassToAntibiotics.size;return indexes;};/**\n * Search pathogens with filtering options\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {Object} options - Search and filter options\n * @returns {Array} - Filtered pathogen results\n */export const searchPathogens=function(indexes){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const{query='',gramStatus='all',// 'all', 'positive', 'negative'\npathogenType='all',// 'all', 'bacteria', 'virus', 'fungus'\nminConditions=0,sortBy='name'// 'name', 'count', 'conditions'\n}=options;let results=[...indexes.pathogens];// Filter by search query\nif(query){const queryLower=query.toLowerCase();results=results.filter(pathogen=>pathogen.name.toLowerCase().includes(queryLower)||pathogen.shortName.toLowerCase().includes(queryLower)||pathogen.details.toLowerCase().includes(queryLower));}// Filter by gram status\nif(gramStatus!=='all'){results=results.filter(pathogen=>pathogen.gramStatus===gramStatus);}// Filter by pathogen type\nif(pathogenType!=='all'){results=results.filter(pathogen=>pathogen.type===pathogenType);}// Filter by minimum conditions\nif(minConditions>0){results=results.filter(pathogen=>pathogen.conditions.length>=minConditions);}// Sort results\nresults.sort((a,b)=>{switch(sortBy){case'count':return b.count-a.count;case'conditions':return b.conditions.length-a.conditions.length;case'name':default:return a.name.localeCompare(b.name);}});return results;};/**\n * Search antibiotics with filtering options\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {Object} options - Search and filter options\n * @returns {Array} - Filtered antibiotic results\n */export const searchAntibiotics=function(indexes){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const{query='',drugClass='all',minConditions=0,sortBy='name'// 'name', 'count', 'conditions', 'class'\n}=options;let results=[...indexes.antibiotics];// Filter by search query\nif(query){const queryLower=query.toLowerCase();results=results.filter(antibiotic=>antibiotic.name.toLowerCase().includes(queryLower)||antibiotic.class.toLowerCase().includes(queryLower));}// Filter by drug class\nif(drugClass!=='all'){results=results.filter(antibiotic=>antibiotic.class===drugClass);}// Filter by minimum conditions\nif(minConditions>0){results=results.filter(antibiotic=>antibiotic.conditions.length>=minConditions);}// Sort results\nresults.sort((a,b)=>{switch(sortBy){case'count':return b.count-a.count;case'conditions':return b.conditions.length-a.conditions.length;case'class':return a.class.localeCompare(b.class)||a.name.localeCompare(b.name);case'name':default:return a.name.localeCompare(b.name);}});return results;};/**\n * Get conditions associated with a specific pathogen\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {string} pathogenName - Name of the pathogen\n * @returns {Array} - Array of condition objects\n */export const getConditionsForPathogen=(indexes,pathogenName)=>{const conditionIds=indexes.pathogenToConditions.get(pathogenName)||[];return conditionIds.map(id=>indexes.conditions.find(condition=>condition.id===id)).filter(Boolean);};/**\n * Get conditions that can be treated with a specific antibiotic\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {string} antibioticName - Name of the antibiotic\n * @returns {Array} - Array of condition objects with therapy context\n */export const getConditionsForAntibiotic=(indexes,antibioticName)=>{const conditionIds=indexes.antibioticToConditions.get(antibioticName)||[];const antibiotic=indexes.antibiotics.find(a=>a.name===antibioticName);return conditionIds.map(id=>{var _antibiotic$therapyCo;const condition=indexes.conditions.find(c=>c.id===id);if(!condition)return null;// Find specific therapy contexts where this antibiotic is mentioned\nconst relevantTherapies={};Object.entries(condition.empiricTherapy||{}).forEach(_ref=>{let[context,therapy]=_ref;if(therapy.toLowerCase().includes(antibioticName.toLowerCase())){relevantTherapies[context]=therapy;}});return _objectSpread(_objectSpread({},condition),{},{relevantTherapies,therapyContexts:(antibiotic===null||antibiotic===void 0?void 0:(_antibiotic$therapyCo=antibiotic.therapyContexts)===null||_antibiotic$therapyCo===void 0?void 0:_antibiotic$therapyCo.filter(ctx=>ctx.includes(condition.name)))||[]});}).filter(Boolean);};/**\n * Get alternative antibiotics for a specific pathogen\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {string} pathogenName - Name of the pathogen\n * @returns {Array} - Array of antibiotic options with context\n */export const getAntibioticsForPathogen=(indexes,pathogenName)=>{const antibioticNames=indexes.pathogenAntibioticMatrix.get(pathogenName)||[];return antibioticNames.map(name=>{const antibiotic=indexes.antibiotics.find(a=>a.name===name);const conditionIds=indexes.pathogenToConditions.get(pathogenName)||[];// Calculate effectiveness score based on how many conditions this antibiotic treats for this pathogen\nconst effectivenessScore=conditionIds.filter(conditionId=>antibiotic===null||antibiotic===void 0?void 0:antibiotic.conditions.includes(conditionId)).length;return _objectSpread(_objectSpread({},antibiotic),{},{effectivenessScore,applicableConditions:conditionIds.filter(conditionId=>antibiotic===null||antibiotic===void 0?void 0:antibiotic.conditions.includes(conditionId))});}).filter(Boolean).sort((a,b)=>b.effectivenessScore-a.effectivenessScore);};/**\n * Find conditions that can be treated with multiple specific antibiotics (combination therapy)\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {Array} antibioticNames - Array of antibiotic names\n * @returns {Array} - Conditions that use these antibiotics together\n */export const findCombinationTherapyConditions=(indexes,antibioticNames)=>{const results=[];indexes.conditions.forEach(condition=>{Object.entries(condition.empiricTherapy||{}).forEach(_ref2=>{let[context,therapy]=_ref2;const therapyLower=therapy.toLowerCase();const matchingAntibiotics=antibioticNames.filter(name=>therapyLower.includes(name.toLowerCase()));if(matchingAntibiotics.length>=2){results.push({condition,context,therapy,matchingAntibiotics});}});});return results;};/**\n * Get drug class statistics\n * @param {Object} indexes - Index structure from buildIndexes\n * @returns {Array} - Array of drug class statistics\n */export const getDrugClassStats=indexes=>{const stats=[];indexes.drugClassToAntibiotics.forEach((antibiotics,drugClass)=>{const totalConditions=new Set();antibiotics.forEach(antibiotic=>{const conditions=indexes.antibioticToConditions.get(antibiotic)||[];conditions.forEach(condition=>totalConditions.add(condition));});stats.push({drugClass,antibiotics:antibiotics.length,conditions:totalConditions.size,antibioticList:antibiotics});});return stats.sort((a,b)=>b.conditions-a.conditions);};/**\n * Calculate pathogen similarity score based on multiple factors\n * @param {Object} pathogen1 - First pathogen object\n * @param {Object} pathogen2 - Second pathogen object\n * @param {Object} indexes - Index structure from buildIndexes\n * @returns {Object} - Similarity analysis with detailed scores\n */export const calculatePathogenSimilarity=(pathogen1,pathogen2,indexes)=>{if(pathogen1.name===pathogen2.name)return{total:1,factors:{}};const similarity={total:0,factors:{gramStatus:0,pathogenType:0,sharedConditions:0,sharedAntibiotics:0,treatmentComplexity:0,resistancePattern:0},details:{sharedConditionNames:[],sharedAntibioticNames:[],uniqueToFirst:[],uniqueToSecond:[]}};// Gram status similarity (0.15 weight)\nif(pathogen1.gramStatus===pathogen2.gramStatus&&pathogen1.gramStatus!=='unknown'){similarity.factors.gramStatus=0.15;}// Pathogen type similarity (0.1 weight)\nif(pathogen1.type===pathogen2.type){similarity.factors.pathogenType=0.1;}// Shared conditions analysis (0.35 weight)\nconst conditions1=new Set(pathogen1.conditions);const conditions2=new Set(pathogen2.conditions);const sharedConditions=[...conditions1].filter(c=>conditions2.has(c));const totalUniqueConditions=new Set([...conditions1,...conditions2]).size;if(totalUniqueConditions>0){similarity.factors.sharedConditions=sharedConditions.length/totalUniqueConditions*0.35;similarity.details.sharedConditionNames=sharedConditions.map(id=>{var _indexes$conditions$f;return((_indexes$conditions$f=indexes.conditions.find(c=>c.id===id))===null||_indexes$conditions$f===void 0?void 0:_indexes$conditions$f.name)||id;});}// Shared antibiotics analysis (0.25 weight)\nconst antibiotics1=new Set(indexes.pathogenAntibioticMatrix.get(pathogen1.name)||[]);const antibiotics2=new Set(indexes.pathogenAntibioticMatrix.get(pathogen2.name)||[]);const sharedAntibiotics=[...antibiotics1].filter(a=>antibiotics2.has(a));const totalUniqueAntibiotics=new Set([...antibiotics1,...antibiotics2]).size;if(totalUniqueAntibiotics>0){similarity.factors.sharedAntibiotics=sharedAntibiotics.length/totalUniqueAntibiotics*0.25;similarity.details.sharedAntibioticNames=sharedAntibiotics;}// Treatment complexity similarity (0.1 weight)\nconst complexity1=pathogen1.conditions.reduce((sum,condId)=>{const complexity=indexes.conditionComplexity.get(condId);return sum+((complexity===null||complexity===void 0?void 0:complexity.total)||0);},0);const complexity2=pathogen2.conditions.reduce((sum,condId)=>{const complexity=indexes.conditionComplexity.get(condId);return sum+((complexity===null||complexity===void 0?void 0:complexity.total)||0);},0);if(complexity1>0&&complexity2>0){const complexityDiff=Math.abs(complexity1-complexity2);const maxComplexity=Math.max(complexity1,complexity2);similarity.factors.treatmentComplexity=Math.max(0,1-complexityDiff/maxComplexity)*0.1;}// Resistance pattern similarity (0.05 weight) - placeholder for future enhancement\n// This could be enhanced with actual resistance data\nsimilarity.factors.resistancePattern=0.05*Math.random();// Placeholder\n// Calculate total similarity\nsimilarity.total=Object.values(similarity.factors).reduce((sum,score)=>sum+score,0);// Add unique condition details\nsimilarity.details.uniqueToFirst=[...conditions1].filter(c=>!conditions2.has(c)).map(id=>{var _indexes$conditions$f2;return((_indexes$conditions$f2=indexes.conditions.find(c=>c.id===id))===null||_indexes$conditions$f2===void 0?void 0:_indexes$conditions$f2.name)||id;});similarity.details.uniqueToSecond=[...conditions2].filter(c=>!conditions1.has(c)).map(id=>{var _indexes$conditions$f3;return((_indexes$conditions$f3=indexes.conditions.find(c=>c.id===id))===null||_indexes$conditions$f3===void 0?void 0:_indexes$conditions$f3.name)||id;});return similarity;};/**\n * Build comprehensive pathogen relationship network\n * @param {Object} indexes - Index structure from buildIndexes\n * @returns {Object} - Network structure with nodes and weighted edges\n */export const buildPathogenNetwork=indexes=>{const network={nodes:[],edges:[],clusters:new Map(),centralityScores:new Map()};// Create nodes for each pathogen\nindexes.pathogens.forEach(pathogen=>{const node={id:pathogen.name,pathogen:pathogen,connections:0,centralityScore:0,clusterData:{gramStatus:pathogen.gramStatus,type:pathogen.type,conditionCount:pathogen.conditions.length}};network.nodes.push(node);});// Calculate edges between pathogens based on similarity\nfor(let i=0;i<indexes.pathogens.length;i++){for(let j=i+1;j<indexes.pathogens.length;j++){const pathogen1=indexes.pathogens[i];const pathogen2=indexes.pathogens[j];const similarity=calculatePathogenSimilarity(pathogen1,pathogen2,indexes);// Only create edges for meaningful similarities (threshold > 0.2)\nif(similarity.total>0.2){const edge={source:pathogen1.name,target:pathogen2.name,weight:similarity.total,similarity:similarity,type:similarity.total>0.6?'strong':similarity.total>0.4?'medium':'weak'};network.edges.push(edge);// Update connection counts\nconst node1=network.nodes.find(n=>n.id===pathogen1.name);const node2=network.nodes.find(n=>n.id===pathogen2.name);if(node1)node1.connections++;if(node2)node2.connections++;}}}// Calculate centrality scores (simplified betweenness centrality)\nnetwork.nodes.forEach(node=>{const connections=network.edges.filter(e=>e.source===node.id||e.target===node.id);const strongConnections=connections.filter(e=>e.type==='strong').length;const mediumConnections=connections.filter(e=>e.type==='medium').length;const weakConnections=connections.filter(e=>e.type==='weak').length;node.centralityScore=(strongConnections*3+mediumConnections*2+weakConnections*1)/network.nodes.length;network.centralityScores.set(node.id,node.centralityScore);});// Identify clusters based on gram status and high connectivity\nconst gramClusters=new Map();network.nodes.forEach(node=>{const gramStatus=node.clusterData.gramStatus;if(!gramClusters.has(gramStatus)){gramClusters.set(gramStatus,[]);}gramClusters.get(gramStatus).push(node);});network.clusters=gramClusters;return network;};/**\n * Find pathogen exploration paths between two pathogens\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {string} startPathogen - Starting pathogen name\n * @param {string} endPathogen - Target pathogen name\n * @param {number} maxDepth - Maximum path depth to explore\n * @returns {Array} - Array of exploration paths with similarities\n */export const findPathogenPaths=function(indexes,startPathogen,endPathogen){let maxDepth=arguments.length>3&&arguments[3]!==undefined?arguments[3]:3;const network=buildPathogenNetwork(indexes);const paths=[];const findPaths=(current,target,path,depth)=>{if(depth>maxDepth)return;if(current===target&&path.length>1){paths.push([...path]);return;}const edges=network.edges.filter(e=>(e.source===current||e.target===current)&&!path.includes(e.source===current?e.target:e.source));edges.forEach(edge=>{const next=edge.source===current?edge.target:edge.source;findPaths(next,target,[...path,next],depth+1);});};findPaths(startPathogen,endPathogen,[startPathogen],0);// Calculate path scores based on edge weights\nreturn paths.map(path=>{let totalScore=0;let pathDetails=[];for(let i=0;i<path.length-1;i++){const edge=network.edges.find(e=>e.source===path[i]&&e.target===path[i+1]||e.source===path[i+1]&&e.target===path[i]);if(edge){totalScore+=edge.weight;pathDetails.push({from:path[i],to:path[i+1],similarity:edge.similarity,weight:edge.weight});}}return{path,score:totalScore/(path.length-1),// Average similarity along path\ndetails:pathDetails,length:path.length};}).sort((a,b)=>b.score-a.score);};/**\n * Get pathogen recommendations based on current selection and user behavior\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {string} currentPathogen - Currently selected pathogen\n * @param {Array} recentlyViewed - Array of recently viewed pathogen names\n * @param {Object} preferences - User learning preferences\n * @returns {Array} - Array of recommended pathogens with reasoning\n */export const getPathogenRecommendations=function(indexes,currentPathogen){let recentlyViewed=arguments.length>2&&arguments[2]!==undefined?arguments[2]:[];let preferences=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};const network=buildPathogenNetwork(indexes);const recommendations=[];const currentNode=network.nodes.find(n=>n.id===currentPathogen);if(!currentNode)return recommendations;// Get direct connections sorted by similarity\nconst directConnections=network.edges.filter(e=>e.source===currentPathogen||e.target===currentPathogen).map(e=>({pathogen:e.source===currentPathogen?e.target:e.source,similarity:e.similarity,weight:e.weight,reasoning:'Direct similarity connection'})).sort((a,b)=>b.weight-a.weight).slice(0,5);recommendations.push(...directConnections);// Get pathogens from same gram status if user prefers systematic learning\nif(preferences.systematicLearning&&currentNode.clusterData.gramStatus!=='unknown'){const sameGramPathogens=indexes.pathogens.filter(p=>p.gramStatus===currentNode.clusterData.gramStatus&&p.name!==currentPathogen&&!recommendations.some(r=>r.pathogen===p.name)).slice(0,3).map(p=>({pathogen:p.name,similarity:{total:0.3,factors:{gramStatus:0.15}},weight:0.3,reasoning:\"Same gram status (\".concat(p.gramStatus,\")\")}));recommendations.push(...sameGramPathogens);}// Get pathogens that treat similar conditions\nconst currentConditions=new Set(currentNode.pathogen.conditions);const conditionBasedRecommendations=indexes.pathogens.filter(p=>{if(p.name===currentPathogen)return false;if(recommendations.some(r=>r.pathogen===p.name))return false;const sharedConditions=p.conditions.filter(c=>currentConditions.has(c));return sharedConditions.length>0;}).map(p=>{const sharedConditions=p.conditions.filter(c=>currentConditions.has(c));const weight=sharedConditions.length/Math.max(currentConditions.size,p.conditions.length);return{pathogen:p.name,similarity:{total:weight,factors:{sharedConditions:weight}},weight:weight,reasoning:\"Treats similar conditions (\".concat(sharedConditions.length,\" shared)\")};}).sort((a,b)=>b.weight-a.weight).slice(0,3);recommendations.push(...conditionBasedRecommendations);// Avoid recently viewed unless specifically requested\nif(!preferences.includeRecentlyViewed){return recommendations.filter(r=>!recentlyViewed.includes(r.pathogen));}return recommendations.slice(0,8);// Limit to top 8 recommendations\n};","map":{"version":3,"names":["processConditionsData","buildIndexes","conditions","processedData","indexes","pathogens","antibiotics","pathogenToConditions","Map","antibioticToConditions","conditionToPathogens","conditionToAntibiotics","gramPositivePathogens","gramNegativePathogens","drugClassToAntibiotics","antibioticToDrugClass","pathogenAntibioticMatrix","conditionComplexity","stats","totalConditions","length","totalPathogens","totalAntibiotics","gramPositiveCount","gramNegativeCount","drugClassCount","forEach","pathogen","set","name","gramStatus","push","conditionId","has","get","antibiotic","class","conditionIds","antibioticsForPathogen","Set","add","Array","from","condition","_indexes$conditionToP","_indexes$conditionToA","pathogenCount","id","antibioticCount","therapyOptions","Object","keys","empiricTherapy","complexityScore","total","size","searchPathogens","options","arguments","undefined","query","pathogenType","minConditions","sortBy","results","queryLower","toLowerCase","filter","includes","shortName","details","type","sort","a","b","count","localeCompare","searchAntibiotics","drugClass","getConditionsForPathogen","pathogenName","map","find","Boolean","getConditionsForAntibiotic","antibioticName","_antibiotic$therapyCo","c","relevantTherapies","entries","_ref","context","therapy","_objectSpread","therapyContexts","ctx","getAntibioticsForPathogen","antibioticNames","effectivenessScore","applicableConditions","findCombinationTherapyConditions","_ref2","therapyLower","matchingAntibiotics","getDrugClassStats","antibioticList","calculatePathogenSimilarity","pathogen1","pathogen2","factors","similarity","sharedConditions","sharedAntibiotics","treatmentComplexity","resistancePattern","sharedConditionNames","sharedAntibioticNames","uniqueToFirst","uniqueToSecond","conditions1","conditions2","totalUniqueConditions","_indexes$conditions$f","antibiotics1","antibiotics2","totalUniqueAntibiotics","complexity1","reduce","sum","condId","complexity","complexity2","complexityDiff","Math","abs","maxComplexity","max","random","values","score","_indexes$conditions$f2","_indexes$conditions$f3","buildPathogenNetwork","network","nodes","edges","clusters","centralityScores","node","connections","centralityScore","clusterData","conditionCount","i","j","edge","source","target","weight","node1","n","node2","e","strongConnections","mediumConnections","weakConnections","gramClusters","findPathogenPaths","startPathogen","endPathogen","maxDepth","paths","findPaths","current","path","depth","next","totalScore","pathDetails","to","getPathogenRecommendations","currentPathogen","recentlyViewed","preferences","recommendations","currentNode","directConnections","reasoning","slice","systematicLearning","sameGramPathogens","p","some","r","concat","currentConditions","conditionBasedRecommendations","includeRecentlyViewed"],"sources":["/Users/joshpankin/My Drive/Obsidian/1. Projects/Antibiotic Learning app/src/utils/dataIndexer.js"],"sourcesContent":["/**\n * Data Indexer\n * Creates reverse indexes and cross-reference maps for multi-dimensional data access\n * Enables efficient lookup of conditions by pathogen, antibiotic, drug class, etc.\n */\n\nimport { processConditionsData } from './dataParser.js';\n\n/**\n * Build comprehensive indexes from processed condition data\n * @param {Array} conditions - Array of medical condition objects\n * @returns {Object} - Complete index structure\n */\nexport const buildIndexes = (conditions) => {\n  const processedData = processConditionsData(conditions);\n  \n  const indexes = {\n    // Primary data\n    conditions: processedData.conditions,\n    pathogens: processedData.pathogens,\n    antibiotics: processedData.antibiotics,\n    \n    // Reverse indexes\n    pathogenToConditions: new Map(),\n    antibioticToConditions: new Map(),\n    conditionToPathogens: new Map(),\n    conditionToAntibiotics: new Map(),\n    \n    // Classification indexes\n    gramPositivePathogens: [],\n    gramNegativePathogens: [],\n    drugClassToAntibiotics: new Map(),\n    antibioticToDrugClass: new Map(),\n    \n    // Cross-reference maps\n    pathogenAntibioticMatrix: new Map(),\n    conditionComplexity: new Map(),\n    \n    // Statistics\n    stats: {\n      totalConditions: conditions.length,\n      totalPathogens: processedData.totalPathogens,\n      totalAntibiotics: processedData.totalAntibiotics,\n      gramPositiveCount: 0,\n      gramNegativeCount: 0,\n      drugClassCount: 0\n    }\n  };\n  \n  // Build pathogen indexes\n  processedData.pathogens.forEach(pathogen => {\n    // Pathogen to conditions mapping\n    indexes.pathogenToConditions.set(pathogen.name, pathogen.conditions);\n    \n    // Classify by gram status\n    if (pathogen.gramStatus === 'positive') {\n      indexes.gramPositivePathogens.push(pathogen);\n      indexes.stats.gramPositiveCount++;\n    } else if (pathogen.gramStatus === 'negative') {\n      indexes.gramNegativePathogens.push(pathogen);\n      indexes.stats.gramNegativeCount++;\n    }\n    \n    // Build condition to pathogens reverse index\n    pathogen.conditions.forEach(conditionId => {\n      if (!indexes.conditionToPathogens.has(conditionId)) {\n        indexes.conditionToPathogens.set(conditionId, []);\n      }\n      indexes.conditionToPathogens.get(conditionId).push(pathogen.name);\n    });\n  });\n  \n  // Build antibiotic indexes\n  processedData.antibiotics.forEach(antibiotic => {\n    // Antibiotic to conditions mapping\n    indexes.antibioticToConditions.set(antibiotic.name, antibiotic.conditions);\n    \n    // Drug class classification\n    if (!indexes.drugClassToAntibiotics.has(antibiotic.class)) {\n      indexes.drugClassToAntibiotics.set(antibiotic.class, []);\n    }\n    indexes.drugClassToAntibiotics.get(antibiotic.class).push(antibiotic.name);\n    indexes.antibioticToDrugClass.set(antibiotic.name, antibiotic.class);\n    \n    // Build condition to antibiotics reverse index\n    antibiotic.conditions.forEach(conditionId => {\n      if (!indexes.conditionToAntibiotics.has(conditionId)) {\n        indexes.conditionToAntibiotics.set(conditionId, []);\n      }\n      indexes.conditionToAntibiotics.get(conditionId).push(antibiotic.name);\n    });\n  });\n  \n  // Build pathogen-antibiotic matrix\n  indexes.pathogenToConditions.forEach((conditionIds, pathogen) => {\n    const antibioticsForPathogen = new Set();\n    \n    conditionIds.forEach(conditionId => {\n      const antibiotics = indexes.conditionToAntibiotics.get(conditionId) || [];\n      antibiotics.forEach(antibiotic => antibioticsForPathogen.add(antibiotic));\n    });\n    \n    indexes.pathogenAntibioticMatrix.set(pathogen, Array.from(antibioticsForPathogen));\n  });\n  \n  // Calculate condition complexity scores\n  conditions.forEach(condition => {\n    const pathogenCount = indexes.conditionToPathogens.get(condition.id)?.length || 0;\n    const antibioticCount = indexes.conditionToAntibiotics.get(condition.id)?.length || 0;\n    const therapyOptions = Object.keys(condition.empiricTherapy || {}).length;\n    \n    const complexityScore = {\n      pathogens: pathogenCount,\n      antibiotics: antibioticCount,\n      therapyOptions: therapyOptions,\n      total: pathogenCount + antibioticCount + therapyOptions\n    };\n    \n    indexes.conditionComplexity.set(condition.id, complexityScore);\n  });\n  \n  // Update final statistics\n  indexes.stats.drugClassCount = indexes.drugClassToAntibiotics.size;\n  \n  return indexes;\n};\n\n/**\n * Search pathogens with filtering options\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {Object} options - Search and filter options\n * @returns {Array} - Filtered pathogen results\n */\nexport const searchPathogens = (indexes, options = {}) => {\n  const {\n    query = '',\n    gramStatus = 'all', // 'all', 'positive', 'negative'\n    pathogenType = 'all', // 'all', 'bacteria', 'virus', 'fungus'\n    minConditions = 0,\n    sortBy = 'name' // 'name', 'count', 'conditions'\n  } = options;\n  \n  let results = [...indexes.pathogens];\n  \n  // Filter by search query\n  if (query) {\n    const queryLower = query.toLowerCase();\n    results = results.filter(pathogen => \n      pathogen.name.toLowerCase().includes(queryLower) ||\n      pathogen.shortName.toLowerCase().includes(queryLower) ||\n      pathogen.details.toLowerCase().includes(queryLower)\n    );\n  }\n  \n  // Filter by gram status\n  if (gramStatus !== 'all') {\n    results = results.filter(pathogen => pathogen.gramStatus === gramStatus);\n  }\n  \n  // Filter by pathogen type\n  if (pathogenType !== 'all') {\n    results = results.filter(pathogen => pathogen.type === pathogenType);\n  }\n  \n  // Filter by minimum conditions\n  if (minConditions > 0) {\n    results = results.filter(pathogen => pathogen.conditions.length >= minConditions);\n  }\n  \n  // Sort results\n  results.sort((a, b) => {\n    switch (sortBy) {\n      case 'count':\n        return b.count - a.count;\n      case 'conditions':\n        return b.conditions.length - a.conditions.length;\n      case 'name':\n      default:\n        return a.name.localeCompare(b.name);\n    }\n  });\n  \n  return results;\n};\n\n/**\n * Search antibiotics with filtering options\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {Object} options - Search and filter options\n * @returns {Array} - Filtered antibiotic results\n */\nexport const searchAntibiotics = (indexes, options = {}) => {\n  const {\n    query = '',\n    drugClass = 'all',\n    minConditions = 0,\n    sortBy = 'name' // 'name', 'count', 'conditions', 'class'\n  } = options;\n  \n  let results = [...indexes.antibiotics];\n  \n  // Filter by search query\n  if (query) {\n    const queryLower = query.toLowerCase();\n    results = results.filter(antibiotic => \n      antibiotic.name.toLowerCase().includes(queryLower) ||\n      antibiotic.class.toLowerCase().includes(queryLower)\n    );\n  }\n  \n  // Filter by drug class\n  if (drugClass !== 'all') {\n    results = results.filter(antibiotic => antibiotic.class === drugClass);\n  }\n  \n  // Filter by minimum conditions\n  if (minConditions > 0) {\n    results = results.filter(antibiotic => antibiotic.conditions.length >= minConditions);\n  }\n  \n  // Sort results\n  results.sort((a, b) => {\n    switch (sortBy) {\n      case 'count':\n        return b.count - a.count;\n      case 'conditions':\n        return b.conditions.length - a.conditions.length;\n      case 'class':\n        return a.class.localeCompare(b.class) || a.name.localeCompare(b.name);\n      case 'name':\n      default:\n        return a.name.localeCompare(b.name);\n    }\n  });\n  \n  return results;\n};\n\n/**\n * Get conditions associated with a specific pathogen\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {string} pathogenName - Name of the pathogen\n * @returns {Array} - Array of condition objects\n */\nexport const getConditionsForPathogen = (indexes, pathogenName) => {\n  const conditionIds = indexes.pathogenToConditions.get(pathogenName) || [];\n  return conditionIds.map(id => \n    indexes.conditions.find(condition => condition.id === id)\n  ).filter(Boolean);\n};\n\n/**\n * Get conditions that can be treated with a specific antibiotic\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {string} antibioticName - Name of the antibiotic\n * @returns {Array} - Array of condition objects with therapy context\n */\nexport const getConditionsForAntibiotic = (indexes, antibioticName) => {\n  const conditionIds = indexes.antibioticToConditions.get(antibioticName) || [];\n  const antibiotic = indexes.antibiotics.find(a => a.name === antibioticName);\n  \n  return conditionIds.map(id => {\n    const condition = indexes.conditions.find(c => c.id === id);\n    if (!condition) return null;\n    \n    // Find specific therapy contexts where this antibiotic is mentioned\n    const relevantTherapies = {};\n    Object.entries(condition.empiricTherapy || {}).forEach(([context, therapy]) => {\n      if (therapy.toLowerCase().includes(antibioticName.toLowerCase())) {\n        relevantTherapies[context] = therapy;\n      }\n    });\n    \n    return {\n      ...condition,\n      relevantTherapies,\n      therapyContexts: antibiotic?.therapyContexts?.filter(ctx => \n        ctx.includes(condition.name)\n      ) || []\n    };\n  }).filter(Boolean);\n};\n\n/**\n * Get alternative antibiotics for a specific pathogen\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {string} pathogenName - Name of the pathogen\n * @returns {Array} - Array of antibiotic options with context\n */\nexport const getAntibioticsForPathogen = (indexes, pathogenName) => {\n  const antibioticNames = indexes.pathogenAntibioticMatrix.get(pathogenName) || [];\n  \n  return antibioticNames.map(name => {\n    const antibiotic = indexes.antibiotics.find(a => a.name === name);\n    const conditionIds = indexes.pathogenToConditions.get(pathogenName) || [];\n    \n    // Calculate effectiveness score based on how many conditions this antibiotic treats for this pathogen\n    const effectivenessScore = conditionIds.filter(conditionId => \n      antibiotic?.conditions.includes(conditionId)\n    ).length;\n    \n    return {\n      ...antibiotic,\n      effectivenessScore,\n      applicableConditions: conditionIds.filter(conditionId => \n        antibiotic?.conditions.includes(conditionId)\n      )\n    };\n  }).filter(Boolean).sort((a, b) => b.effectivenessScore - a.effectivenessScore);\n};\n\n/**\n * Find conditions that can be treated with multiple specific antibiotics (combination therapy)\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {Array} antibioticNames - Array of antibiotic names\n * @returns {Array} - Conditions that use these antibiotics together\n */\nexport const findCombinationTherapyConditions = (indexes, antibioticNames) => {\n  const results = [];\n  \n  indexes.conditions.forEach(condition => {\n    Object.entries(condition.empiricTherapy || {}).forEach(([context, therapy]) => {\n      const therapyLower = therapy.toLowerCase();\n      const matchingAntibiotics = antibioticNames.filter(name => \n        therapyLower.includes(name.toLowerCase())\n      );\n      \n      if (matchingAntibiotics.length >= 2) {\n        results.push({\n          condition,\n          context,\n          therapy,\n          matchingAntibiotics\n        });\n      }\n    });\n  });\n  \n  return results;\n};\n\n/**\n * Get drug class statistics\n * @param {Object} indexes - Index structure from buildIndexes\n * @returns {Array} - Array of drug class statistics\n */\nexport const getDrugClassStats = (indexes) => {\n  const stats = [];\n  \n  indexes.drugClassToAntibiotics.forEach((antibiotics, drugClass) => {\n    const totalConditions = new Set();\n    antibiotics.forEach(antibiotic => {\n      const conditions = indexes.antibioticToConditions.get(antibiotic) || [];\n      conditions.forEach(condition => totalConditions.add(condition));\n    });\n    \n    stats.push({\n      drugClass,\n      antibiotics: antibiotics.length,\n      conditions: totalConditions.size,\n      antibioticList: antibiotics\n    });\n  });\n  \n  return stats.sort((a, b) => b.conditions - a.conditions);\n};\n\n/**\n * Calculate pathogen similarity score based on multiple factors\n * @param {Object} pathogen1 - First pathogen object\n * @param {Object} pathogen2 - Second pathogen object\n * @param {Object} indexes - Index structure from buildIndexes\n * @returns {Object} - Similarity analysis with detailed scores\n */\nexport const calculatePathogenSimilarity = (pathogen1, pathogen2, indexes) => {\n  if (pathogen1.name === pathogen2.name) return { total: 1, factors: {} };\n  \n  const similarity = {\n    total: 0,\n    factors: {\n      gramStatus: 0,\n      pathogenType: 0,\n      sharedConditions: 0,\n      sharedAntibiotics: 0,\n      treatmentComplexity: 0,\n      resistancePattern: 0\n    },\n    details: {\n      sharedConditionNames: [],\n      sharedAntibioticNames: [],\n      uniqueToFirst: [],\n      uniqueToSecond: []\n    }\n  };\n  \n  // Gram status similarity (0.15 weight)\n  if (pathogen1.gramStatus === pathogen2.gramStatus && pathogen1.gramStatus !== 'unknown') {\n    similarity.factors.gramStatus = 0.15;\n  }\n  \n  // Pathogen type similarity (0.1 weight)\n  if (pathogen1.type === pathogen2.type) {\n    similarity.factors.pathogenType = 0.1;\n  }\n  \n  // Shared conditions analysis (0.35 weight)\n  const conditions1 = new Set(pathogen1.conditions);\n  const conditions2 = new Set(pathogen2.conditions);\n  const sharedConditions = [...conditions1].filter(c => conditions2.has(c));\n  const totalUniqueConditions = new Set([...conditions1, ...conditions2]).size;\n  \n  if (totalUniqueConditions > 0) {\n    similarity.factors.sharedConditions = (sharedConditions.length / totalUniqueConditions) * 0.35;\n    similarity.details.sharedConditionNames = sharedConditions.map(id => \n      indexes.conditions.find(c => c.id === id)?.name || id\n    );\n  }\n  \n  // Shared antibiotics analysis (0.25 weight)\n  const antibiotics1 = new Set(indexes.pathogenAntibioticMatrix.get(pathogen1.name) || []);\n  const antibiotics2 = new Set(indexes.pathogenAntibioticMatrix.get(pathogen2.name) || []);\n  const sharedAntibiotics = [...antibiotics1].filter(a => antibiotics2.has(a));\n  const totalUniqueAntibiotics = new Set([...antibiotics1, ...antibiotics2]).size;\n  \n  if (totalUniqueAntibiotics > 0) {\n    similarity.factors.sharedAntibiotics = (sharedAntibiotics.length / totalUniqueAntibiotics) * 0.25;\n    similarity.details.sharedAntibioticNames = sharedAntibiotics;\n  }\n  \n  // Treatment complexity similarity (0.1 weight)\n  const complexity1 = pathogen1.conditions.reduce((sum, condId) => {\n    const complexity = indexes.conditionComplexity.get(condId);\n    return sum + (complexity?.total || 0);\n  }, 0);\n  const complexity2 = pathogen2.conditions.reduce((sum, condId) => {\n    const complexity = indexes.conditionComplexity.get(condId);\n    return sum + (complexity?.total || 0);\n  }, 0);\n  \n  if (complexity1 > 0 && complexity2 > 0) {\n    const complexityDiff = Math.abs(complexity1 - complexity2);\n    const maxComplexity = Math.max(complexity1, complexity2);\n    similarity.factors.treatmentComplexity = Math.max(0, (1 - complexityDiff / maxComplexity)) * 0.1;\n  }\n  \n  // Resistance pattern similarity (0.05 weight) - placeholder for future enhancement\n  // This could be enhanced with actual resistance data\n  similarity.factors.resistancePattern = 0.05 * Math.random(); // Placeholder\n  \n  // Calculate total similarity\n  similarity.total = Object.values(similarity.factors).reduce((sum, score) => sum + score, 0);\n  \n  // Add unique condition details\n  similarity.details.uniqueToFirst = [...conditions1].filter(c => !conditions2.has(c))\n    .map(id => indexes.conditions.find(c => c.id === id)?.name || id);\n  similarity.details.uniqueToSecond = [...conditions2].filter(c => !conditions1.has(c))\n    .map(id => indexes.conditions.find(c => c.id === id)?.name || id);\n  \n  return similarity;\n};\n\n/**\n * Build comprehensive pathogen relationship network\n * @param {Object} indexes - Index structure from buildIndexes\n * @returns {Object} - Network structure with nodes and weighted edges\n */\nexport const buildPathogenNetwork = (indexes) => {\n  const network = {\n    nodes: [],\n    edges: [],\n    clusters: new Map(),\n    centralityScores: new Map()\n  };\n  \n  // Create nodes for each pathogen\n  indexes.pathogens.forEach(pathogen => {\n    const node = {\n      id: pathogen.name,\n      pathogen: pathogen,\n      connections: 0,\n      centralityScore: 0,\n      clusterData: {\n        gramStatus: pathogen.gramStatus,\n        type: pathogen.type,\n        conditionCount: pathogen.conditions.length\n      }\n    };\n    network.nodes.push(node);\n  });\n  \n  // Calculate edges between pathogens based on similarity\n  for (let i = 0; i < indexes.pathogens.length; i++) {\n    for (let j = i + 1; j < indexes.pathogens.length; j++) {\n      const pathogen1 = indexes.pathogens[i];\n      const pathogen2 = indexes.pathogens[j];\n      const similarity = calculatePathogenSimilarity(pathogen1, pathogen2, indexes);\n      \n      // Only create edges for meaningful similarities (threshold > 0.2)\n      if (similarity.total > 0.2) {\n        const edge = {\n          source: pathogen1.name,\n          target: pathogen2.name,\n          weight: similarity.total,\n          similarity: similarity,\n          type: similarity.total > 0.6 ? 'strong' : similarity.total > 0.4 ? 'medium' : 'weak'\n        };\n        \n        network.edges.push(edge);\n        \n        // Update connection counts\n        const node1 = network.nodes.find(n => n.id === pathogen1.name);\n        const node2 = network.nodes.find(n => n.id === pathogen2.name);\n        if (node1) node1.connections++;\n        if (node2) node2.connections++;\n      }\n    }\n  }\n  \n  // Calculate centrality scores (simplified betweenness centrality)\n  network.nodes.forEach(node => {\n    const connections = network.edges.filter(e => e.source === node.id || e.target === node.id);\n    const strongConnections = connections.filter(e => e.type === 'strong').length;\n    const mediumConnections = connections.filter(e => e.type === 'medium').length;\n    const weakConnections = connections.filter(e => e.type === 'weak').length;\n    \n    node.centralityScore = (strongConnections * 3 + mediumConnections * 2 + weakConnections * 1) / network.nodes.length;\n    network.centralityScores.set(node.id, node.centralityScore);\n  });\n  \n  // Identify clusters based on gram status and high connectivity\n  const gramClusters = new Map();\n  network.nodes.forEach(node => {\n    const gramStatus = node.clusterData.gramStatus;\n    if (!gramClusters.has(gramStatus)) {\n      gramClusters.set(gramStatus, []);\n    }\n    gramClusters.get(gramStatus).push(node);\n  });\n  \n  network.clusters = gramClusters;\n  \n  return network;\n};\n\n/**\n * Find pathogen exploration paths between two pathogens\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {string} startPathogen - Starting pathogen name\n * @param {string} endPathogen - Target pathogen name\n * @param {number} maxDepth - Maximum path depth to explore\n * @returns {Array} - Array of exploration paths with similarities\n */\nexport const findPathogenPaths = (indexes, startPathogen, endPathogen, maxDepth = 3) => {\n  const network = buildPathogenNetwork(indexes);\n  const paths = [];\n  \n  const findPaths = (current, target, path, depth) => {\n    if (depth > maxDepth) return;\n    if (current === target && path.length > 1) {\n      paths.push([...path]);\n      return;\n    }\n    \n    const edges = network.edges.filter(e => \n      (e.source === current || e.target === current) && \n      !path.includes(e.source === current ? e.target : e.source)\n    );\n    \n    edges.forEach(edge => {\n      const next = edge.source === current ? edge.target : edge.source;\n      findPaths(next, target, [...path, next], depth + 1);\n    });\n  };\n  \n  findPaths(startPathogen, endPathogen, [startPathogen], 0);\n  \n  // Calculate path scores based on edge weights\n  return paths.map(path => {\n    let totalScore = 0;\n    let pathDetails = [];\n    \n    for (let i = 0; i < path.length - 1; i++) {\n      const edge = network.edges.find(e => \n        (e.source === path[i] && e.target === path[i + 1]) ||\n        (e.source === path[i + 1] && e.target === path[i])\n      );\n      \n      if (edge) {\n        totalScore += edge.weight;\n        pathDetails.push({\n          from: path[i],\n          to: path[i + 1],\n          similarity: edge.similarity,\n          weight: edge.weight\n        });\n      }\n    }\n    \n    return {\n      path,\n      score: totalScore / (path.length - 1), // Average similarity along path\n      details: pathDetails,\n      length: path.length\n    };\n  }).sort((a, b) => b.score - a.score);\n};\n\n/**\n * Get pathogen recommendations based on current selection and user behavior\n * @param {Object} indexes - Index structure from buildIndexes\n * @param {string} currentPathogen - Currently selected pathogen\n * @param {Array} recentlyViewed - Array of recently viewed pathogen names\n * @param {Object} preferences - User learning preferences\n * @returns {Array} - Array of recommended pathogens with reasoning\n */\nexport const getPathogenRecommendations = (indexes, currentPathogen, recentlyViewed = [], preferences = {}) => {\n  const network = buildPathogenNetwork(indexes);\n  const recommendations = [];\n  \n  const currentNode = network.nodes.find(n => n.id === currentPathogen);\n  if (!currentNode) return recommendations;\n  \n  // Get direct connections sorted by similarity\n  const directConnections = network.edges\n    .filter(e => e.source === currentPathogen || e.target === currentPathogen)\n    .map(e => ({\n      pathogen: e.source === currentPathogen ? e.target : e.source,\n      similarity: e.similarity,\n      weight: e.weight,\n      reasoning: 'Direct similarity connection'\n    }))\n    .sort((a, b) => b.weight - a.weight)\n    .slice(0, 5);\n  \n  recommendations.push(...directConnections);\n  \n  // Get pathogens from same gram status if user prefers systematic learning\n  if (preferences.systematicLearning && currentNode.clusterData.gramStatus !== 'unknown') {\n    const sameGramPathogens = indexes.pathogens\n      .filter(p => \n        p.gramStatus === currentNode.clusterData.gramStatus && \n        p.name !== currentPathogen &&\n        !recommendations.some(r => r.pathogen === p.name)\n      )\n      .slice(0, 3)\n      .map(p => ({\n        pathogen: p.name,\n        similarity: { total: 0.3, factors: { gramStatus: 0.15 } },\n        weight: 0.3,\n        reasoning: `Same gram status (${p.gramStatus})`\n      }));\n    \n    recommendations.push(...sameGramPathogens);\n  }\n  \n  // Get pathogens that treat similar conditions\n  const currentConditions = new Set(currentNode.pathogen.conditions);\n  const conditionBasedRecommendations = indexes.pathogens\n    .filter(p => {\n      if (p.name === currentPathogen) return false;\n      if (recommendations.some(r => r.pathogen === p.name)) return false;\n      \n      const sharedConditions = p.conditions.filter(c => currentConditions.has(c));\n      return sharedConditions.length > 0;\n    })\n    .map(p => {\n      const sharedConditions = p.conditions.filter(c => currentConditions.has(c));\n      const weight = sharedConditions.length / Math.max(currentConditions.size, p.conditions.length);\n      \n      return {\n        pathogen: p.name,\n        similarity: { total: weight, factors: { sharedConditions: weight } },\n        weight: weight,\n        reasoning: `Treats similar conditions (${sharedConditions.length} shared)`\n      };\n    })\n    .sort((a, b) => b.weight - a.weight)\n    .slice(0, 3);\n  \n  recommendations.push(...conditionBasedRecommendations);\n  \n  // Avoid recently viewed unless specifically requested\n  if (!preferences.includeRecentlyViewed) {\n    return recommendations.filter(r => !recentlyViewed.includes(r.pathogen));\n  }\n  \n  return recommendations.slice(0, 8); // Limit to top 8 recommendations\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}