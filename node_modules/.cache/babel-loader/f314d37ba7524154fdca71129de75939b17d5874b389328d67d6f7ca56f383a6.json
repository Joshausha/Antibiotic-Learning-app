{"ast":null,"code":"/**\n * Advanced Data Parser\n * Extracts and normalizes pathogen and antibiotic information from medical conditions data\n * Handles complex text patterns and creates standardized lists for multi-dimensional exploration\n */\n\n/**\n * Extract and normalize pathogen names from commonPathogens arrays\n * @param {string} pathogenText - Raw pathogen text from data\n * @returns {Object} - Normalized pathogen info with metadata\n */\nexport const parsePathogen = pathogenText => {\n  if (!pathogenText || typeof pathogenText !== 'string') {\n    return null;\n  }\n\n  // Clean up the text\n  let cleanText = pathogenText.trim();\n\n  // Remove citation markers and references\n  cleanText = cleanText.replace(/\\[cite.*?\\]/g, '');\n  cleanText = cleanText.replace(/\\(cite.*?\\)/g, '');\n\n  // Skip entries that are clearly not pathogens (references, notes, etc.)\n  const nonPathogenPatterns = [/^RCTs for/i, /^Observational studies/i, /et al/i, /^Studies/i, /^Research/i];\n  if (nonPathogenPatterns.some(pattern => pattern.test(cleanText))) {\n    return null;\n  }\n\n  // Extract the main pathogen name\n  let mainName = cleanText;\n  let details = '';\n  let gramStatus = 'unknown';\n  let pathogenType = 'bacteria';\n\n  // Handle parenthetical information\n  const parenthesesMatch = cleanText.match(/^([^(]+)\\s*\\(([^)]+)\\)/);\n  if (parenthesesMatch) {\n    mainName = parenthesesMatch[1].trim();\n    details = parenthesesMatch[2].trim();\n  }\n\n  // Determine gram status based on pathogen name\n  const gramPositivePatterns = [/staphylococcus/i, /streptococcus/i, /enterococcus/i, /clostridium/i, /corynebacterium/i, /bacillus/i, /listeria/i];\n  const gramNegativePatterns = [/escherichia/i, /klebsiella/i, /pseudomonas/i, /enterobacter/i, /proteus/i, /citrobacter/i, /haemophilus/i, /moraxella/i, /neisseria/i, /enterobacterales/i];\n  if (gramPositivePatterns.some(pattern => pattern.test(mainName))) {\n    gramStatus = 'positive';\n  } else if (gramNegativePatterns.some(pattern => pattern.test(mainName))) {\n    gramStatus = 'negative';\n  }\n\n  // Determine pathogen type\n  if (/virus/i.test(cleanText) || /viral/i.test(cleanText)) {\n    pathogenType = 'virus';\n  } else if (/fungal/i.test(cleanText) || /candida/i.test(cleanText)) {\n    pathogenType = 'fungus';\n  } else if (/mycobacteri/i.test(cleanText)) {\n    pathogenType = 'mycobacteria';\n  }\n\n  // Standardize common abbreviations\n  const abbreviationMap = {\n    'S aureus': 'Staphylococcus aureus',\n    'S pyogenes': 'Streptococcus pyogenes',\n    'S pneumoniae': 'Streptococcus pneumoniae',\n    'E coli': 'Escherichia coli',\n    'E faecalis': 'Enterococcus faecalis',\n    'E faecium': 'Enterococcus faecium',\n    'H influenzae': 'Haemophilus influenzae',\n    'P aeruginosa': 'Pseudomonas aeruginosa',\n    'K kingae': 'Kingella kingae',\n    'K pneumoniae': 'Klebsiella pneumoniae',\n    'M catarrhalis': 'Moraxella catarrhalis',\n    'N meningitidis': 'Neisseria meningitidis',\n    'GBS': 'Group B Streptococcus',\n    'HSV': 'Herpes Simplex Virus'\n  };\n  const standardizedName = abbreviationMap[mainName] || mainName;\n  return {\n    originalText: pathogenText,\n    name: standardizedName,\n    shortName: mainName,\n    details: details,\n    gramStatus: gramStatus,\n    type: pathogenType,\n    isValid: true\n  };\n};\n\n/**\n * Extract antibiotic names from therapy strings\n * @param {string} therapyText - Raw therapy text from empiricTherapy\n * @returns {Array} - Array of antibiotic objects with metadata\n */\nexport const parseAntibiotics = therapyText => {\n  if (!therapyText || typeof therapyText !== 'string') {\n    return [];\n  }\n  let cleanText = therapyText.trim();\n\n  // Remove non-drug instructions and context\n  const instructionPatterns = [/Consider surgical drainage[^.]*\\./i, /Drainage[^.]*\\./i, /Choice depends on[^.]*\\./i, /These are empiric[^.]*\\./i, /if.*available\\)/i, /some experts[^)]*\\)/i];\n  instructionPatterns.forEach(pattern => {\n    cleanText = cleanText.replace(pattern, '');\n  });\n\n  // Handle empty or non-specific guidance\n  if (!cleanText.trim() || /choice depends/i.test(cleanText) || /guided by culture/i.test(cleanText)) {\n    return [];\n  }\n  const antibiotics = [];\n\n  // Split on combinations and alternatives\n  const segments = cleanText.split(/\\s+(?:PLUS|plus|\\+|OR|or)\\s+/i);\n  segments.forEach(segment => {\n    const antibiotic = parseAntibiotic(segment.trim());\n    if (antibiotic) {\n      antibiotics.push(antibiotic);\n    }\n  });\n  return antibiotics;\n};\n\n/**\n * Parse individual antibiotic from text segment\n * @param {string} text - Text segment containing antibiotic name\n * @returns {Object|null} - Antibiotic object or null if invalid\n */\nconst parseAntibiotic = text => {\n  if (!text || text.length < 2) return null;\n\n  // Remove parenthetical information\n  let cleanName = text.replace(/\\([^)]*\\)/g, '').trim();\n\n  // Remove dosing information and routes\n  cleanName = cleanName.replace(/\\d+\\s*(mg|g|units|mcg).*$/i, '');\n  cleanName = cleanName.replace(/\\b(IV|PO|IM|oral|intravenous|intramuscular)\\b/gi, '');\n\n  // Skip if it's not actually a drug name\n  const nonDrugPatterns = [/^if\\b/i, /^for\\b/i, /^consider\\b/i, /^add\\b/i, /days?$/i, /weeks?$/i, /\\d+\\s*days?/i, /allergyb?:?/i, /standard/i, /treatment/i];\n  if (nonDrugPatterns.some(pattern => pattern.test(cleanName))) {\n    return null;\n  }\n\n  // Standardize drug names\n  const drugMap = {\n    'Ampicillin-sulbactam': 'Ampicillin/sulbactam',\n    'Ampicillin- sulbactam': 'Ampicillin/sulbactam',\n    'Amoxicillin-clavulanate': 'Amoxicillin/clavulanate',\n    'Amoxicillin- clavulanate': 'Amoxicillin/clavulanate',\n    'Piperacillin-tazobactam': 'Piperacillin/tazobactam',\n    'Piperacillin- tazobactam': 'Piperacillin/tazobactam',\n    'TMP-SMX': 'Trimethoprim/sulfamethoxazole',\n    'TMP/SMX': 'Trimethoprim/sulfamethoxazole'\n  };\n  const standardizedName = drugMap[cleanName] || cleanName;\n\n  // Determine drug class\n  const drugClass = getDrugClass(standardizedName);\n  return {\n    originalText: text,\n    name: standardizedName,\n    class: drugClass,\n    isValid: true\n  };\n};\n\n/**\n * Determine drug class based on antibiotic name\n * @param {string} drugName - Standardized drug name\n * @returns {string} - Drug class\n */\nconst getDrugClass = drugName => {\n  const drugClasses = {\n    'Penicillins': ['Penicillin', 'Ampicillin', 'Amoxicillin', 'Oxacillin', 'Nafcillin', 'Ampicillin/sulbactam', 'Amoxicillin/clavulanate', 'Piperacillin/tazobactam'],\n    'Cephalosporins': ['Cefazolin', 'Cephalexin', 'Ceftriaxone', 'Cefotaxime', 'Ceftazidime', 'Cefepime', 'Cefdinir', 'Cefpodoxime', 'Cefuroxime', 'Ceftaroline'],\n    'Glycopeptides': ['Vancomycin'],\n    'Lincosamides': ['Clindamycin'],\n    'Oxazolidinones': ['Linezolid'],\n    'Lipopeptides': ['Daptomycin'],\n    'Macrolides': ['Azithromycin', 'Erythromycin'],\n    'Aminoglycosides': ['Gentamicin', 'Amikacin', 'Tobramycin'],\n    'Fluoroquinolones': ['Ciprofloxacin', 'Levofloxacin'],\n    'Tetracyclines': ['Doxycycline'],\n    'Folate Antagonists': ['Trimethoprim/sulfamethoxazole'],\n    'Nitroimidazoles': ['Metronidazole'],\n    'Nitrofurans': ['Nitrofurantoin'],\n    'Antivirals': ['Acyclovir']\n  };\n  for (const [className, drugs] of Object.entries(drugClasses)) {\n    if (drugs.some(drug => drugName.includes(drug) || drug.includes(drugName))) {\n      return className;\n    }\n  }\n  return 'Other';\n};\n\n/**\n * Process all conditions and extract normalized pathogen and antibiotic data\n * @param {Array} conditions - Array of medical condition objects\n * @returns {Object} - Processed data with pathogens and antibiotics\n */\nexport const processConditionsData = conditions => {\n  const pathogens = new Map();\n  const antibiotics = new Map();\n  const conditionMap = new Map();\n  conditions.forEach(condition => {\n    conditionMap.set(condition.id, condition);\n\n    // Process pathogens\n    if (condition.commonPathogens && Array.isArray(condition.commonPathogens)) {\n      condition.commonPathogens.forEach(pathogenText => {\n        const pathogen = parsePathogen(pathogenText);\n        if (pathogen && pathogen.isValid) {\n          if (!pathogens.has(pathogen.name)) {\n            pathogens.set(pathogen.name, {\n              ...pathogen,\n              conditions: new Set(),\n              count: 0\n            });\n          }\n          const pathogenData = pathogens.get(pathogen.name);\n          pathogenData.conditions.add(condition.id);\n          pathogenData.count++;\n        }\n      });\n    }\n\n    // Process antibiotics from empiric therapy\n    if (condition.empiricTherapy && typeof condition.empiricTherapy === 'object') {\n      Object.values(condition.empiricTherapy).forEach(therapyText => {\n        const antibioticsList = parseAntibiotics(therapyText);\n        antibioticsList.forEach(antibiotic => {\n          if (antibiotic && antibiotic.isValid) {\n            if (!antibiotics.has(antibiotic.name)) {\n              antibiotics.set(antibiotic.name, {\n                ...antibiotic,\n                conditions: new Set(),\n                therapyContexts: new Set(),\n                count: 0\n              });\n            }\n            const antibioticData = antibiotics.get(antibiotic.name);\n            antibioticData.conditions.add(condition.id);\n            antibioticData.therapyContexts.add(`${condition.name}: ${therapyText}`);\n            antibioticData.count++;\n          }\n        });\n      });\n    }\n  });\n\n  // Convert Sets to Arrays for serialization\n  const pathogenArray = Array.from(pathogens.values()).map(p => ({\n    ...p,\n    conditions: Array.from(p.conditions),\n    therapyContexts: undefined\n  }));\n  const antibioticArray = Array.from(antibiotics.values()).map(a => ({\n    ...a,\n    conditions: Array.from(a.conditions),\n    therapyContexts: Array.from(a.therapyContexts)\n  }));\n  return {\n    pathogens: pathogenArray,\n    antibiotics: antibioticArray,\n    totalPathogens: pathogenArray.length,\n    totalAntibiotics: antibioticArray.length,\n    conditions: Array.from(conditionMap.values())\n  };\n};","map":{"version":3,"names":["parsePathogen","pathogenText","cleanText","trim","replace","nonPathogenPatterns","some","pattern","test","mainName","details","gramStatus","pathogenType","parenthesesMatch","match","gramPositivePatterns","gramNegativePatterns","abbreviationMap","standardizedName","originalText","name","shortName","type","isValid","parseAntibiotics","therapyText","instructionPatterns","forEach","antibiotics","segments","split","segment","antibiotic","parseAntibiotic","push","text","length","cleanName","nonDrugPatterns","drugMap","drugClass","getDrugClass","class","drugName","drugClasses","className","drugs","Object","entries","drug","includes","processConditionsData","conditions","pathogens","Map","conditionMap","condition","set","id","commonPathogens","Array","isArray","pathogen","has","Set","count","pathogenData","get","add","empiricTherapy","values","antibioticsList","therapyContexts","antibioticData","pathogenArray","from","map","p","undefined","antibioticArray","a","totalPathogens","totalAntibiotics"],"sources":["/Users/joshpankin/My Drive/Obsidian/1. Projects/Antibiotic Learning app/src/utils/dataParser.js"],"sourcesContent":["/**\n * Advanced Data Parser\n * Extracts and normalizes pathogen and antibiotic information from medical conditions data\n * Handles complex text patterns and creates standardized lists for multi-dimensional exploration\n */\n\n/**\n * Extract and normalize pathogen names from commonPathogens arrays\n * @param {string} pathogenText - Raw pathogen text from data\n * @returns {Object} - Normalized pathogen info with metadata\n */\nexport const parsePathogen = (pathogenText) => {\n  if (!pathogenText || typeof pathogenText !== 'string') {\n    return null;\n  }\n\n  // Clean up the text\n  let cleanText = pathogenText.trim();\n  \n  // Remove citation markers and references\n  cleanText = cleanText.replace(/\\[cite.*?\\]/g, '');\n  cleanText = cleanText.replace(/\\(cite.*?\\)/g, '');\n  \n  // Skip entries that are clearly not pathogens (references, notes, etc.)\n  const nonPathogenPatterns = [\n    /^RCTs for/i,\n    /^Observational studies/i,\n    /et al/i,\n    /^Studies/i,\n    /^Research/i\n  ];\n  \n  if (nonPathogenPatterns.some(pattern => pattern.test(cleanText))) {\n    return null;\n  }\n  \n  // Extract the main pathogen name\n  let mainName = cleanText;\n  let details = '';\n  let gramStatus = 'unknown';\n  let pathogenType = 'bacteria';\n  \n  // Handle parenthetical information\n  const parenthesesMatch = cleanText.match(/^([^(]+)\\s*\\(([^)]+)\\)/);\n  if (parenthesesMatch) {\n    mainName = parenthesesMatch[1].trim();\n    details = parenthesesMatch[2].trim();\n  }\n  \n  // Determine gram status based on pathogen name\n  const gramPositivePatterns = [\n    /staphylococcus/i,\n    /streptococcus/i,\n    /enterococcus/i,\n    /clostridium/i,\n    /corynebacterium/i,\n    /bacillus/i,\n    /listeria/i\n  ];\n  \n  const gramNegativePatterns = [\n    /escherichia/i,\n    /klebsiella/i,\n    /pseudomonas/i,\n    /enterobacter/i,\n    /proteus/i,\n    /citrobacter/i,\n    /haemophilus/i,\n    /moraxella/i,\n    /neisseria/i,\n    /enterobacterales/i\n  ];\n  \n  if (gramPositivePatterns.some(pattern => pattern.test(mainName))) {\n    gramStatus = 'positive';\n  } else if (gramNegativePatterns.some(pattern => pattern.test(mainName))) {\n    gramStatus = 'negative';\n  }\n  \n  // Determine pathogen type\n  if (/virus/i.test(cleanText) || /viral/i.test(cleanText)) {\n    pathogenType = 'virus';\n  } else if (/fungal/i.test(cleanText) || /candida/i.test(cleanText)) {\n    pathogenType = 'fungus';\n  } else if (/mycobacteri/i.test(cleanText)) {\n    pathogenType = 'mycobacteria';\n  }\n  \n  // Standardize common abbreviations\n  const abbreviationMap = {\n    'S aureus': 'Staphylococcus aureus',\n    'S pyogenes': 'Streptococcus pyogenes', \n    'S pneumoniae': 'Streptococcus pneumoniae',\n    'E coli': 'Escherichia coli',\n    'E faecalis': 'Enterococcus faecalis',\n    'E faecium': 'Enterococcus faecium',\n    'H influenzae': 'Haemophilus influenzae',\n    'P aeruginosa': 'Pseudomonas aeruginosa',\n    'K kingae': 'Kingella kingae',\n    'K pneumoniae': 'Klebsiella pneumoniae',\n    'M catarrhalis': 'Moraxella catarrhalis',\n    'N meningitidis': 'Neisseria meningitidis',\n    'GBS': 'Group B Streptococcus',\n    'HSV': 'Herpes Simplex Virus'\n  };\n  \n  const standardizedName = abbreviationMap[mainName] || mainName;\n  \n  return {\n    originalText: pathogenText,\n    name: standardizedName,\n    shortName: mainName,\n    details: details,\n    gramStatus: gramStatus,\n    type: pathogenType,\n    isValid: true\n  };\n};\n\n/**\n * Extract antibiotic names from therapy strings\n * @param {string} therapyText - Raw therapy text from empiricTherapy\n * @returns {Array} - Array of antibiotic objects with metadata\n */\nexport const parseAntibiotics = (therapyText) => {\n  if (!therapyText || typeof therapyText !== 'string') {\n    return [];\n  }\n  \n  let cleanText = therapyText.trim();\n  \n  // Remove non-drug instructions and context\n  const instructionPatterns = [\n    /Consider surgical drainage[^.]*\\./i,\n    /Drainage[^.]*\\./i,\n    /Choice depends on[^.]*\\./i,\n    /These are empiric[^.]*\\./i,\n    /if.*available\\)/i,\n    /some experts[^)]*\\)/i\n  ];\n  \n  instructionPatterns.forEach(pattern => {\n    cleanText = cleanText.replace(pattern, '');\n  });\n  \n  // Handle empty or non-specific guidance\n  if (!cleanText.trim() || \n      /choice depends/i.test(cleanText) || \n      /guided by culture/i.test(cleanText)) {\n    return [];\n  }\n  \n  const antibiotics = [];\n  \n  // Split on combinations and alternatives\n  const segments = cleanText.split(/\\s+(?:PLUS|plus|\\+|OR|or)\\s+/i);\n  \n  segments.forEach(segment => {\n    const antibiotic = parseAntibiotic(segment.trim());\n    if (antibiotic) {\n      antibiotics.push(antibiotic);\n    }\n  });\n  \n  return antibiotics;\n};\n\n/**\n * Parse individual antibiotic from text segment\n * @param {string} text - Text segment containing antibiotic name\n * @returns {Object|null} - Antibiotic object or null if invalid\n */\nconst parseAntibiotic = (text) => {\n  if (!text || text.length < 2) return null;\n  \n  // Remove parenthetical information\n  let cleanName = text.replace(/\\([^)]*\\)/g, '').trim();\n  \n  // Remove dosing information and routes\n  cleanName = cleanName.replace(/\\d+\\s*(mg|g|units|mcg).*$/i, '');\n  cleanName = cleanName.replace(/\\b(IV|PO|IM|oral|intravenous|intramuscular)\\b/gi, '');\n  \n  // Skip if it's not actually a drug name\n  const nonDrugPatterns = [\n    /^if\\b/i,\n    /^for\\b/i, \n    /^consider\\b/i,\n    /^add\\b/i,\n    /days?$/i,\n    /weeks?$/i,\n    /\\d+\\s*days?/i,\n    /allergyb?:?/i,\n    /standard/i,\n    /treatment/i\n  ];\n  \n  if (nonDrugPatterns.some(pattern => pattern.test(cleanName))) {\n    return null;\n  }\n  \n  // Standardize drug names\n  const drugMap = {\n    'Ampicillin-sulbactam': 'Ampicillin/sulbactam',\n    'Ampicillin- sulbactam': 'Ampicillin/sulbactam',\n    'Amoxicillin-clavulanate': 'Amoxicillin/clavulanate', \n    'Amoxicillin- clavulanate': 'Amoxicillin/clavulanate',\n    'Piperacillin-tazobactam': 'Piperacillin/tazobactam',\n    'Piperacillin- tazobactam': 'Piperacillin/tazobactam',\n    'TMP-SMX': 'Trimethoprim/sulfamethoxazole',\n    'TMP/SMX': 'Trimethoprim/sulfamethoxazole'\n  };\n  \n  const standardizedName = drugMap[cleanName] || cleanName;\n  \n  // Determine drug class\n  const drugClass = getDrugClass(standardizedName);\n  \n  return {\n    originalText: text,\n    name: standardizedName,\n    class: drugClass,\n    isValid: true\n  };\n};\n\n/**\n * Determine drug class based on antibiotic name\n * @param {string} drugName - Standardized drug name\n * @returns {string} - Drug class\n */\nconst getDrugClass = (drugName) => {\n  const drugClasses = {\n    'Penicillins': [\n      'Penicillin', 'Ampicillin', 'Amoxicillin', 'Oxacillin', 'Nafcillin',\n      'Ampicillin/sulbactam', 'Amoxicillin/clavulanate', 'Piperacillin/tazobactam'\n    ],\n    'Cephalosporins': [\n      'Cefazolin', 'Cephalexin', 'Ceftriaxone', 'Cefotaxime', 'Ceftazidime', \n      'Cefepime', 'Cefdinir', 'Cefpodoxime', 'Cefuroxime', 'Ceftaroline'\n    ],\n    'Glycopeptides': ['Vancomycin'],\n    'Lincosamides': ['Clindamycin'],\n    'Oxazolidinones': ['Linezolid'],\n    'Lipopeptides': ['Daptomycin'],\n    'Macrolides': ['Azithromycin', 'Erythromycin'],\n    'Aminoglycosides': ['Gentamicin', 'Amikacin', 'Tobramycin'],\n    'Fluoroquinolones': ['Ciprofloxacin', 'Levofloxacin'],\n    'Tetracyclines': ['Doxycycline'],\n    'Folate Antagonists': ['Trimethoprim/sulfamethoxazole'],\n    'Nitroimidazoles': ['Metronidazole'],\n    'Nitrofurans': ['Nitrofurantoin'],\n    'Antivirals': ['Acyclovir']\n  };\n  \n  for (const [className, drugs] of Object.entries(drugClasses)) {\n    if (drugs.some(drug => drugName.includes(drug) || drug.includes(drugName))) {\n      return className;\n    }\n  }\n  \n  return 'Other';\n};\n\n/**\n * Process all conditions and extract normalized pathogen and antibiotic data\n * @param {Array} conditions - Array of medical condition objects\n * @returns {Object} - Processed data with pathogens and antibiotics\n */\nexport const processConditionsData = (conditions) => {\n  const pathogens = new Map();\n  const antibiotics = new Map();\n  const conditionMap = new Map();\n  \n  conditions.forEach(condition => {\n    conditionMap.set(condition.id, condition);\n    \n    // Process pathogens\n    if (condition.commonPathogens && Array.isArray(condition.commonPathogens)) {\n      condition.commonPathogens.forEach(pathogenText => {\n        const pathogen = parsePathogen(pathogenText);\n        if (pathogen && pathogen.isValid) {\n          if (!pathogens.has(pathogen.name)) {\n            pathogens.set(pathogen.name, {\n              ...pathogen,\n              conditions: new Set(),\n              count: 0\n            });\n          }\n          \n          const pathogenData = pathogens.get(pathogen.name);\n          pathogenData.conditions.add(condition.id);\n          pathogenData.count++;\n        }\n      });\n    }\n    \n    // Process antibiotics from empiric therapy\n    if (condition.empiricTherapy && typeof condition.empiricTherapy === 'object') {\n      Object.values(condition.empiricTherapy).forEach(therapyText => {\n        const antibioticsList = parseAntibiotics(therapyText);\n        antibioticsList.forEach(antibiotic => {\n          if (antibiotic && antibiotic.isValid) {\n            if (!antibiotics.has(antibiotic.name)) {\n              antibiotics.set(antibiotic.name, {\n                ...antibiotic,\n                conditions: new Set(),\n                therapyContexts: new Set(),\n                count: 0\n              });\n            }\n            \n            const antibioticData = antibiotics.get(antibiotic.name);\n            antibioticData.conditions.add(condition.id);\n            antibioticData.therapyContexts.add(`${condition.name}: ${therapyText}`);\n            antibioticData.count++;\n          }\n        });\n      });\n    }\n  });\n  \n  // Convert Sets to Arrays for serialization\n  const pathogenArray = Array.from(pathogens.values()).map(p => ({\n    ...p,\n    conditions: Array.from(p.conditions),\n    therapyContexts: undefined\n  }));\n  \n  const antibioticArray = Array.from(antibiotics.values()).map(a => ({\n    ...a,\n    conditions: Array.from(a.conditions),\n    therapyContexts: Array.from(a.therapyContexts)\n  }));\n  \n  return {\n    pathogens: pathogenArray,\n    antibiotics: antibioticArray,\n    totalPathogens: pathogenArray.length,\n    totalAntibiotics: antibioticArray.length,\n    conditions: Array.from(conditionMap.values())\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}