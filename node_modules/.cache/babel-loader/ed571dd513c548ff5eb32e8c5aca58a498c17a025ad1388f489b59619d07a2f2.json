{"ast":null,"code":"/**\n * Recommendation Engine Utilities\n * Pure functions for calculating pathogen recommendations and behavior analysis\n * Extracted from usePathogenRecommendations hook for better separation of concerns\n */\n\n/**\n * Analyzes user behavior patterns from interaction history\n */\nexport const analyzeBehaviorPatterns = userBehavior => {\n  var _Array$from$sort$;\n  if (!userBehavior.history || userBehavior.history.length === 0) {\n    return {\n      mostViewedCategories: [],\n      gramStatusPreference: null,\n      averageSessionLength: 0,\n      explorationStyle: 'systematic',\n      difficultyProgression: 'steady'\n    };\n  }\n  const history = userBehavior.history;\n  const categoryCount = new Map();\n  const gramStatusCount = new Map();\n  let totalSessionTime = 0;\n  history.forEach(item => {\n    var _item$pathogen, _item$pathogen2;\n    // Count categories\n    if ((_item$pathogen = item.pathogen) !== null && _item$pathogen !== void 0 && _item$pathogen.conditions) {\n      item.pathogen.conditions.forEach(conditionId => {\n        // This would need condition lookup logic\n        const category = item.category || 'Unknown';\n        categoryCount.set(category, (categoryCount.get(category) || 0) + 1);\n      });\n    }\n\n    // Count gram status preferences\n    if ((_item$pathogen2 = item.pathogen) !== null && _item$pathogen2 !== void 0 && _item$pathogen2.gramStatus) {\n      gramStatusCount.set(item.pathogen.gramStatus, (gramStatusCount.get(item.pathogen.gramStatus) || 0) + 1);\n    }\n\n    // Track session time\n    totalSessionTime += item.timeSpent || 0;\n  });\n\n  // Determine exploration style\n  const explorationStyle = determineExplorationStyle(history);\n  return {\n    mostViewedCategories: Array.from(categoryCount.entries()).sort(([, a], [, b]) => b - a).slice(0, 3).map(([category]) => category),\n    gramStatusPreference: ((_Array$from$sort$ = Array.from(gramStatusCount.entries()).sort(([, a], [, b]) => b - a)[0]) === null || _Array$from$sort$ === void 0 ? void 0 : _Array$from$sort$[0]) || null,\n    averageSessionLength: totalSessionTime / history.length,\n    explorationStyle,\n    difficultyProgression: 'steady' // Could be enhanced based on patterns\n  };\n};\n\n/**\n * Determines user's exploration style based on interaction patterns\n */\nconst determineExplorationStyle = history => {\n  if (history.length < 3) return 'systematic';\n\n  // Analyze pattern consistency\n  const categories = history.map(item => {\n    var _item$pathogen3;\n    return (_item$pathogen3 = item.pathogen) === null || _item$pathogen3 === void 0 ? void 0 : _item$pathogen3.category;\n  }).filter(Boolean);\n  const uniqueCategories = new Set(categories);\n  if (uniqueCategories.size === 1) return 'focused';\n  if (uniqueCategories.size / categories.length > 0.8) return 'random';\n  return 'systematic';\n};\n\n/**\n * Calculates pathogen recommendations based on current selection and user behavior\n */\nexport const calculatePathogenRecommendations = (indexes, selectedPathogen, behaviorAnalysis, userPreferences) => {\n  if (!indexes || !selectedPathogen) return [];\n  const recommendations = [];\n\n  // Get similar pathogens\n  const similarPathogens = findSimilarPathogens(indexes, selectedPathogen);\n  recommendations.push(...similarPathogens.map(pathogen => ({\n    ...pathogen,\n    reasoning: 'Similar pathogen characteristics',\n    score: calculateSimilarityScore(pathogen, selectedPathogen),\n    category: 'Similar'\n  })));\n\n  // Get recommendations based on user preferences\n  if (behaviorAnalysis.mostViewedCategories.length > 0) {\n    const categoryRecommendations = findPathogensByCategories(indexes, behaviorAnalysis.mostViewedCategories);\n    recommendations.push(...categoryRecommendations.map(pathogen => ({\n      ...pathogen,\n      reasoning: 'Matches your learning interests',\n      score: calculateUserRelevanceScore(pathogen, behaviorAnalysis),\n      category: 'Your Interests'\n    })));\n  }\n\n  // Add difficulty progression recommendations\n  const nextLevelPathogens = findNextLevelPathogens(indexes, selectedPathogen);\n  recommendations.push(...nextLevelPathogens.map(pathogen => ({\n    ...pathogen,\n    reasoning: 'Next difficulty level',\n    score: calculateDifficultyScore(pathogen),\n    category: 'Next Level'\n  })));\n\n  // Remove duplicates and sort by score\n  const uniqueRecommendations = removeDuplicateRecommendations(recommendations);\n  return uniqueRecommendations.sort((a, b) => b.score - a.score).slice(0, 8); // Limit to top 8 recommendations\n};\n\n/**\n * Finds pathogens similar to the selected one\n */\nconst findSimilarPathogens = (indexes, selectedPathogen) => {\n  if (!indexes.pathogens) return [];\n  return indexes.pathogens.filter(pathogen => pathogen.name !== selectedPathogen.name).filter(pathogen => {\n    var _pathogen$conditions;\n    // Same gram status\n    if (pathogen.gramStatus === selectedPathogen.gramStatus) return true;\n\n    // Shared conditions\n    const sharedConditions = ((_pathogen$conditions = pathogen.conditions) === null || _pathogen$conditions === void 0 ? void 0 : _pathogen$conditions.filter(condition => {\n      var _selectedPathogen$con;\n      return (_selectedPathogen$con = selectedPathogen.conditions) === null || _selectedPathogen$con === void 0 ? void 0 : _selectedPathogen$con.includes(condition);\n    })) || [];\n    return sharedConditions.length > 0;\n  }).slice(0, 4);\n};\n\n/**\n * Finds pathogens by user's preferred categories\n */\nconst findPathogensByCategories = (indexes, preferredCategories) => {\n  if (!indexes.pathogens) return [];\n  return indexes.pathogens.filter(pathogen => {\n    // This would need proper category lookup\n    return preferredCategories.some(category => pathogen.category === category);\n  }).slice(0, 3);\n};\n\n/**\n * Finds pathogens at the next difficulty level\n */\nconst findNextLevelPathogens = (indexes, selectedPathogen) => {\n  var _selectedPathogen$con2;\n  if (!indexes.pathogens) return [];\n  const currentComplexity = ((_selectedPathogen$con2 = selectedPathogen.conditions) === null || _selectedPathogen$con2 === void 0 ? void 0 : _selectedPathogen$con2.length) || 0;\n  return indexes.pathogens.filter(pathogen => {\n    var _pathogen$conditions2;\n    const pathogenComplexity = ((_pathogen$conditions2 = pathogen.conditions) === null || _pathogen$conditions2 === void 0 ? void 0 : _pathogen$conditions2.length) || 0;\n    return pathogenComplexity > currentComplexity && pathogenComplexity <= currentComplexity + 2;\n  }).slice(0, 3);\n};\n\n/**\n * Calculates similarity score between two pathogens\n */\nconst calculateSimilarityScore = (pathogen1, pathogen2) => {\n  var _pathogen1$conditions;\n  let score = 0;\n\n  // Gram status match\n  if (pathogen1.gramStatus === pathogen2.gramStatus) score += 30;\n\n  // Shared conditions\n  const sharedConditions = ((_pathogen1$conditions = pathogen1.conditions) === null || _pathogen1$conditions === void 0 ? void 0 : _pathogen1$conditions.filter(condition => {\n    var _pathogen2$conditions;\n    return (_pathogen2$conditions = pathogen2.conditions) === null || _pathogen2$conditions === void 0 ? void 0 : _pathogen2$conditions.includes(condition);\n  })) || [];\n  score += sharedConditions.length * 20;\n\n  // Morphology similarity (if available)\n  if (pathogen1.morphology === pathogen2.morphology) score += 15;\n  return Math.min(score, 100);\n};\n\n/**\n * Calculates user relevance score\n */\nconst calculateUserRelevanceScore = (pathogen, behaviorAnalysis) => {\n  let score = 50; // Base score\n\n  // Category preference match\n  if (behaviorAnalysis.mostViewedCategories.includes(pathogen.category)) {\n    score += 25;\n  }\n\n  // Gram status preference match\n  if (pathogen.gramStatus === behaviorAnalysis.gramStatusPreference) {\n    score += 20;\n  }\n  return Math.min(score, 100);\n};\n\n/**\n * Calculates difficulty score for progression\n */\nconst calculateDifficultyScore = pathogen => {\n  var _pathogen$conditions3;\n  const complexity = ((_pathogen$conditions3 = pathogen.conditions) === null || _pathogen$conditions3 === void 0 ? void 0 : _pathogen$conditions3.length) || 0;\n  return Math.min(complexity * 10, 100);\n};\n\n/**\n * Removes duplicate recommendations based on pathogen name\n */\nconst removeDuplicateRecommendations = recommendations => {\n  const seen = new Set();\n  return recommendations.filter(rec => {\n    if (seen.has(rec.name)) return false;\n    seen.add(rec.name);\n    return true;\n  });\n};\n\n/**\n * Generates a structured learning path\n */\nexport const generateLearningPath = (indexes, userPreferences, behaviorAnalysis) => {\n  if (!indexes) return [];\n  const learningPath = [];\n  if (userPreferences.systematicLearning) {\n    var _indexes$pathogens, _indexes$pathogens2;\n    // Create systematic progression by gram status\n    const gramPositive = ((_indexes$pathogens = indexes.pathogens) === null || _indexes$pathogens === void 0 ? void 0 : _indexes$pathogens.filter(p => p.gramStatus === 'Positive')) || [];\n    const gramNegative = ((_indexes$pathogens2 = indexes.pathogens) === null || _indexes$pathogens2 === void 0 ? void 0 : _indexes$pathogens2.filter(p => p.gramStatus === 'Negative')) || [];\n    learningPath.push({\n      section: 'Gram-Positive Bacteria',\n      pathogens: gramPositive.slice(0, 5),\n      reasoning: 'Systematic learning: Gram-positive organisms'\n    });\n    learningPath.push({\n      section: 'Gram-Negative Bacteria',\n      pathogens: gramNegative.slice(0, 5),\n      reasoning: 'Systematic learning: Gram-negative organisms'\n    });\n  } else {\n    // Create interest-based learning path\n    if (behaviorAnalysis.mostViewedCategories.length > 0) {\n      behaviorAnalysis.mostViewedCategories.forEach(category => {\n        const categoryPathogens = findPathogensByCategories(indexes, [category]);\n        if (categoryPathogens.length > 0) {\n          learningPath.push({\n            section: `${category} Focus`,\n            pathogens: categoryPathogens,\n            reasoning: `Based on your interest in ${category}`\n          });\n        }\n      });\n    }\n  }\n  return learningPath;\n};\n\n/**\n * Categorizes recommendations for better organization\n */\nexport const categorizeRecommendations = (recommendations, selectedPathogen) => {\n  const categorized = {\n    'Similar': recommendations.filter(r => r.category === 'Similar'),\n    'Your Interests': recommendations.filter(r => r.category === 'Your Interests'),\n    'Next Level': recommendations.filter(r => r.category === 'Next Level'),\n    'Recently Popular': recommendations.filter(r => r.category === 'Recently Popular'),\n    'Discover': recommendations.filter(r => !['Similar', 'Your Interests', 'Next Level', 'Recently Popular'].includes(r.category))\n  };\n\n  // Filter out empty categories\n  return Object.fromEntries(Object.entries(categorized).filter(([, recs]) => recs.length > 0));\n};","map":{"version":3,"names":["analyzeBehaviorPatterns","userBehavior","_Array$from$sort$","history","length","mostViewedCategories","gramStatusPreference","averageSessionLength","explorationStyle","difficultyProgression","categoryCount","Map","gramStatusCount","totalSessionTime","forEach","item","_item$pathogen","_item$pathogen2","pathogen","conditions","conditionId","category","set","get","gramStatus","timeSpent","determineExplorationStyle","Array","from","entries","sort","a","b","slice","map","categories","_item$pathogen3","filter","Boolean","uniqueCategories","Set","size","calculatePathogenRecommendations","indexes","selectedPathogen","behaviorAnalysis","userPreferences","recommendations","similarPathogens","findSimilarPathogens","push","reasoning","score","calculateSimilarityScore","categoryRecommendations","findPathogensByCategories","calculateUserRelevanceScore","nextLevelPathogens","findNextLevelPathogens","calculateDifficultyScore","uniqueRecommendations","removeDuplicateRecommendations","pathogens","name","_pathogen$conditions","sharedConditions","condition","_selectedPathogen$con","includes","preferredCategories","some","_selectedPathogen$con2","currentComplexity","_pathogen$conditions2","pathogenComplexity","pathogen1","pathogen2","_pathogen1$conditions","_pathogen2$conditions","morphology","Math","min","_pathogen$conditions3","complexity","seen","rec","has","add","generateLearningPath","learningPath","systematicLearning","_indexes$pathogens","_indexes$pathogens2","gramPositive","p","gramNegative","section","categoryPathogens","categorizeRecommendations","categorized","r","Object","fromEntries","recs"],"sources":["/Users/joshpankin/My Drive/Obsidian/1. Projects/Antibiotic Learning app/src/utils/recommendationEngine.js"],"sourcesContent":["/**\n * Recommendation Engine Utilities\n * Pure functions for calculating pathogen recommendations and behavior analysis\n * Extracted from usePathogenRecommendations hook for better separation of concerns\n */\n\n/**\n * Analyzes user behavior patterns from interaction history\n */\nexport const analyzeBehaviorPatterns = (userBehavior) => {\n  if (!userBehavior.history || userBehavior.history.length === 0) {\n    return {\n      mostViewedCategories: [],\n      gramStatusPreference: null,\n      averageSessionLength: 0,\n      explorationStyle: 'systematic',\n      difficultyProgression: 'steady'\n    };\n  }\n\n  const history = userBehavior.history;\n  const categoryCount = new Map();\n  const gramStatusCount = new Map();\n  let totalSessionTime = 0;\n  \n  history.forEach(item => {\n    // Count categories\n    if (item.pathogen?.conditions) {\n      item.pathogen.conditions.forEach(conditionId => {\n        // This would need condition lookup logic\n        const category = item.category || 'Unknown';\n        categoryCount.set(category, (categoryCount.get(category) || 0) + 1);\n      });\n    }\n    \n    // Count gram status preferences\n    if (item.pathogen?.gramStatus) {\n      gramStatusCount.set(\n        item.pathogen.gramStatus,\n        (gramStatusCount.get(item.pathogen.gramStatus) || 0) + 1\n      );\n    }\n    \n    // Track session time\n    totalSessionTime += item.timeSpent || 0;\n  });\n\n  // Determine exploration style\n  const explorationStyle = determineExplorationStyle(history);\n  \n  return {\n    mostViewedCategories: Array.from(categoryCount.entries())\n      .sort(([,a], [,b]) => b - a)\n      .slice(0, 3)\n      .map(([category]) => category),\n    gramStatusPreference: Array.from(gramStatusCount.entries())\n      .sort(([,a], [,b]) => b - a)[0]?.[0] || null,\n    averageSessionLength: totalSessionTime / history.length,\n    explorationStyle,\n    difficultyProgression: 'steady' // Could be enhanced based on patterns\n  };\n};\n\n/**\n * Determines user's exploration style based on interaction patterns\n */\nconst determineExplorationStyle = (history) => {\n  if (history.length < 3) return 'systematic';\n  \n  // Analyze pattern consistency\n  const categories = history.map(item => item.pathogen?.category).filter(Boolean);\n  const uniqueCategories = new Set(categories);\n  \n  if (uniqueCategories.size === 1) return 'focused';\n  if (uniqueCategories.size / categories.length > 0.8) return 'random';\n  return 'systematic';\n};\n\n/**\n * Calculates pathogen recommendations based on current selection and user behavior\n */\nexport const calculatePathogenRecommendations = (indexes, selectedPathogen, behaviorAnalysis, userPreferences) => {\n  if (!indexes || !selectedPathogen) return [];\n\n  const recommendations = [];\n  \n  // Get similar pathogens\n  const similarPathogens = findSimilarPathogens(indexes, selectedPathogen);\n  recommendations.push(...similarPathogens.map(pathogen => ({\n    ...pathogen,\n    reasoning: 'Similar pathogen characteristics',\n    score: calculateSimilarityScore(pathogen, selectedPathogen),\n    category: 'Similar'\n  })));\n\n  // Get recommendations based on user preferences\n  if (behaviorAnalysis.mostViewedCategories.length > 0) {\n    const categoryRecommendations = findPathogensByCategories(\n      indexes, \n      behaviorAnalysis.mostViewedCategories\n    );\n    recommendations.push(...categoryRecommendations.map(pathogen => ({\n      ...pathogen,\n      reasoning: 'Matches your learning interests',\n      score: calculateUserRelevanceScore(pathogen, behaviorAnalysis),\n      category: 'Your Interests'\n    })));\n  }\n\n  // Add difficulty progression recommendations\n  const nextLevelPathogens = findNextLevelPathogens(indexes, selectedPathogen);\n  recommendations.push(...nextLevelPathogens.map(pathogen => ({\n    ...pathogen,\n    reasoning: 'Next difficulty level',\n    score: calculateDifficultyScore(pathogen),\n    category: 'Next Level'\n  })));\n\n  // Remove duplicates and sort by score\n  const uniqueRecommendations = removeDuplicateRecommendations(recommendations);\n  return uniqueRecommendations\n    .sort((a, b) => b.score - a.score)\n    .slice(0, 8); // Limit to top 8 recommendations\n};\n\n/**\n * Finds pathogens similar to the selected one\n */\nconst findSimilarPathogens = (indexes, selectedPathogen) => {\n  if (!indexes.pathogens) return [];\n  \n  return indexes.pathogens\n    .filter(pathogen => pathogen.name !== selectedPathogen.name)\n    .filter(pathogen => {\n      // Same gram status\n      if (pathogen.gramStatus === selectedPathogen.gramStatus) return true;\n      \n      // Shared conditions\n      const sharedConditions = pathogen.conditions?.filter(condition =>\n        selectedPathogen.conditions?.includes(condition)\n      ) || [];\n      \n      return sharedConditions.length > 0;\n    })\n    .slice(0, 4);\n};\n\n/**\n * Finds pathogens by user's preferred categories\n */\nconst findPathogensByCategories = (indexes, preferredCategories) => {\n  if (!indexes.pathogens) return [];\n  \n  return indexes.pathogens.filter(pathogen => {\n    // This would need proper category lookup\n    return preferredCategories.some(category => \n      pathogen.category === category\n    );\n  }).slice(0, 3);\n};\n\n/**\n * Finds pathogens at the next difficulty level\n */\nconst findNextLevelPathogens = (indexes, selectedPathogen) => {\n  if (!indexes.pathogens) return [];\n  \n  const currentComplexity = selectedPathogen.conditions?.length || 0;\n  \n  return indexes.pathogens\n    .filter(pathogen => {\n      const pathogenComplexity = pathogen.conditions?.length || 0;\n      return pathogenComplexity > currentComplexity && \n             pathogenComplexity <= currentComplexity + 2;\n    })\n    .slice(0, 3);\n};\n\n/**\n * Calculates similarity score between two pathogens\n */\nconst calculateSimilarityScore = (pathogen1, pathogen2) => {\n  let score = 0;\n  \n  // Gram status match\n  if (pathogen1.gramStatus === pathogen2.gramStatus) score += 30;\n  \n  // Shared conditions\n  const sharedConditions = pathogen1.conditions?.filter(condition =>\n    pathogen2.conditions?.includes(condition)\n  ) || [];\n  score += sharedConditions.length * 20;\n  \n  // Morphology similarity (if available)\n  if (pathogen1.morphology === pathogen2.morphology) score += 15;\n  \n  return Math.min(score, 100);\n};\n\n/**\n * Calculates user relevance score\n */\nconst calculateUserRelevanceScore = (pathogen, behaviorAnalysis) => {\n  let score = 50; // Base score\n  \n  // Category preference match\n  if (behaviorAnalysis.mostViewedCategories.includes(pathogen.category)) {\n    score += 25;\n  }\n  \n  // Gram status preference match\n  if (pathogen.gramStatus === behaviorAnalysis.gramStatusPreference) {\n    score += 20;\n  }\n  \n  return Math.min(score, 100);\n};\n\n/**\n * Calculates difficulty score for progression\n */\nconst calculateDifficultyScore = (pathogen) => {\n  const complexity = pathogen.conditions?.length || 0;\n  return Math.min(complexity * 10, 100);\n};\n\n/**\n * Removes duplicate recommendations based on pathogen name\n */\nconst removeDuplicateRecommendations = (recommendations) => {\n  const seen = new Set();\n  return recommendations.filter(rec => {\n    if (seen.has(rec.name)) return false;\n    seen.add(rec.name);\n    return true;\n  });\n};\n\n/**\n * Generates a structured learning path\n */\nexport const generateLearningPath = (indexes, userPreferences, behaviorAnalysis) => {\n  if (!indexes) return [];\n\n  const learningPath = [];\n  \n  if (userPreferences.systematicLearning) {\n    // Create systematic progression by gram status\n    const gramPositive = indexes.pathogens?.filter(p => p.gramStatus === 'Positive') || [];\n    const gramNegative = indexes.pathogens?.filter(p => p.gramStatus === 'Negative') || [];\n    \n    learningPath.push({\n      section: 'Gram-Positive Bacteria',\n      pathogens: gramPositive.slice(0, 5),\n      reasoning: 'Systematic learning: Gram-positive organisms'\n    });\n    \n    learningPath.push({\n      section: 'Gram-Negative Bacteria', \n      pathogens: gramNegative.slice(0, 5),\n      reasoning: 'Systematic learning: Gram-negative organisms'\n    });\n  } else {\n    // Create interest-based learning path\n    if (behaviorAnalysis.mostViewedCategories.length > 0) {\n      behaviorAnalysis.mostViewedCategories.forEach(category => {\n        const categoryPathogens = findPathogensByCategories(indexes, [category]);\n        if (categoryPathogens.length > 0) {\n          learningPath.push({\n            section: `${category} Focus`,\n            pathogens: categoryPathogens,\n            reasoning: `Based on your interest in ${category}`\n          });\n        }\n      });\n    }\n  }\n  \n  return learningPath;\n};\n\n/**\n * Categorizes recommendations for better organization\n */\nexport const categorizeRecommendations = (recommendations, selectedPathogen) => {\n  const categorized = {\n    'Similar': recommendations.filter(r => r.category === 'Similar'),\n    'Your Interests': recommendations.filter(r => r.category === 'Your Interests'),\n    'Next Level': recommendations.filter(r => r.category === 'Next Level'),\n    'Recently Popular': recommendations.filter(r => r.category === 'Recently Popular'),\n    'Discover': recommendations.filter(r => \n      !['Similar', 'Your Interests', 'Next Level', 'Recently Popular'].includes(r.category)\n    )\n  };\n\n  // Filter out empty categories\n  return Object.fromEntries(\n    Object.entries(categorized).filter(([, recs]) => recs.length > 0)\n  );\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}